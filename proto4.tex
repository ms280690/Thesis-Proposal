\documentclass[thesis-solanki.tex]{subfiles}


\begin{document}

\chapter{Prototype 4}{\label{proto4}}


Our aim to embedd IO into the DSL

So something like a "data" declaration for IO operations

\begin{minted}[linenos]{haskell}
-- http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/

data IOAction a = 
-- A container for a value of type a.
                  Return a 
-- A container holding a String to be printed to stdout, followed by another IOAction a.
                | Put String (IOAction a) 
-- A container holding a function from String -> IOAction a, which can be applied to whatever String is read from stdin.
                | Get (String -> IOAction a)
{--

Return 1

Put "hello" (Return ())
Put "hello" (
  Return ()
)

Put "hello" (Return 1)
Put "hello" (
  Return 1
)

Put "hello" (get)
Put "hello" (
  Get ($0 -> 
    Return "$0"
  )
)

Get put
Get ($0 -> 
  Put "$0" (
    Return ()
  )
)

--}

-- Read and return
get :: IOAction String
get   = Get Return
{--

Get ($0 -> 
  Return "$0"
)

--}

-- Print and return.
put :: String -> IOAction ()
put s = Put s (Return ())
{--

put "hello"
Put "hello" (
  Return ()
)

--}

-- (>>=) Action sequencer and combiner :- read -> write -> read -> write -> ........
seqio :: IOAction a -> (a -> IOAction b) -> IOAction b
--      (First action   (Take and perform                       
--      which generates  next action)
--      value a) 
seqio (Return a) f = f a
seqio (Put s io) f = Put s (seqio io f)
seqio (Get g)    f = Get (\s -> seqio (g s) f)

--Take input and print.
echo :: IOAction ()
echo = get `seqio` put
{--

Get ($0 -> 
  Put "$0" (
    Return ()
  )
)

--}

hello :: IOAction ()
hello = put "What is your name?"      `seqio` \_    ->
        get                           `seqio` \name ->
        put "What is your age?"       `seqio` \_    ->
        get                           `seqio` \age  ->
        put ("Hello " ++ name ++ "!") `seqio` \_    -> 
        put ("You are " ++ age ++ " years old")
{--

Put "What is your name?" (
  Get ($0 -> 
    Put "What is your age?" (
      Get ($1 -> 
        Put "Hello $0!" (
          Put "You are $1 years old" (
            Return ()
          )
        )
      )
    )
  )
)

run hello
What is your name?
Mehul
What is your age?
25
Hello Mehul!
You are 25 years old

--}

-- hello in "do" block since IOAction is a Monad
hello2 :: IOAction ()
hello2 = do put "What is your name?"
            name <- get
            put "What is your age?"
            age <- get
            put ("Hello, " ++ name ++ "!")
            put ("You are " ++ age ++ " years old!")
{--

Put "What is your name?" (
  Get ($0 -> 
    Put "What is your age?" (
      Get ($1 -> 
        Put "Hello, $0!" (
          Put "You are $1 years old!" (
            Return ()
          )
        )
      )
    )
  )
)

run hello2
What is your name?
Mehul
What is your age?
25
Hello, Mehul!
You are 25 years old!

--}

-- where the effects happen.
-- "Real" IO functions like return, putStrLn, getLine.
run :: IOAction a -> IO a
run (Return a) = return a
run (Put s io) = putStrLn s >> run io
run (Get f)    = getLine >>= run . f
{--

run (Return 1)
1

run (Put "hello" get)
hello
1
"1"

run (Get put)
1
1

--}


-- Glue code that makes everything play nice --

instance Monad IOAction where
    return = Return
    (>>=)  = seqio

instance Show a => Show (IOAction a) where
  show io = go 0 0 io
    where
      go m n (Return a) = ind m "Return " ++ show a
      go m n (Put s io) = ind m "Put " ++ show s ++ " (\n" ++ go (m+2) n io ++ "\n" ++ ind m ")"
      go m n (Get g)    = let i = "$" ++ show n
                          in ind m "Get (" ++ i ++ " -> \n" ++ go (m+2) (n+1) (g i) ++ "\n" ++ ind m ")"

      ind m s = replicate m ' ' ++ s

-- IOAction is also a Functor --

mapio :: (a -> b) -> IOAction a -> IOAction b
mapio f (Return a) = Return (f a)
mapio f (Put s io) = Put s (mapio f io)
mapio f (Get g)    = Get (\s -> mapio f (g s))
{--

mapio (+1) (Return 1)
Return 2

mapio (id) (Put "hello" get)
Put "hello" (
  Get ($0 -> 
    Return "$0"
  )
)

mapio (id) (Get put)
Get ($0 -> 
  Put "$0" (
    Return ()
  )
)

--}

instance Functor IOAction where
    fmap = mapio



\end{minted}

So when the program is getting interpreted the interpreter encounters an IO operation which then gets "interpreted" to the above and it 
continues normally.

The interpreted program is still pure since the IO actions have not been executed 

if the running is done inside a monad then the IO still is pure.

\begin{minted}[linenos]{haskell}
-- Prolog IO

{--
FREE MONADS
In general, a structure is called free when it is left-adjoint to a forgetful functor.
In this specific instance, the Term data type is a higher-order functor that maps
a functor f to the monad Term f ; this is illustrated by the above two instance
definitions. This Term functor is left-adjoint to the forgetful functor from monads
to their underlying functors.
--}

data Term f a = Pure a 
			  | Impure (f (Term f a))

main 							= undefined

instance Functor f => Functor (Term f) where
	fmap f (Pure x ) 			= Pure (f x )
	fmap f (Impure t) 			= Impure (fmap (fmap f ) t)

instance Functor f => Monad (Term f) where
	return x 					= Pure x
	(Pure x ) 	>>= 	f 		= f x
	(Impure t) 	>>= 	f 		= Impure (fmap (>>= f ) t)

\end{minted}


\begin{minted}[linenos]{haskell}
import Data.Traversable
import Control.Monad
import Data.Functor
import Control.Applicative
import System.IO

data PrologResult
   = NoResult
   | Cons OneBinding PrologResult 
   | IOIn (IO String) (String -> PrologResult)
   | IOOut (IO ()) PrologResult



data OneBinding = Pair VariableName VariableName


--data MiniLang a = MyData a | Empty | Input   

--runInIO :: PrologResult -> IO [OneBinding]


data PrologIO a = Input (IO a) | Output (a -> IO ()) | PrologData a | Empty 
--				deriving (Show, Eq, Ord)
{--
instance Functor (PrologIO) where
	fmap f Empty 					= Empty
	fmap f (Input (IO a)) 			= Input (IO (f a))
--	fmap f (Output (a -> IO ()))	= Output (a -> IO ())
--	fmap f (PrologData a)			= PrologData (f a)
--}

instance Monad PrologIO where
	 	return a = PrologData a
--	 	(Input i) >>= (Output o) = i >>= (\a -> (o a))

instance (Show a) => Show (PrologIO a) where
	show (Empty) 		= show "No result"
	show (PrologData a) = show a
--	show (Input f)		= show (f ++ "")
--	show (Output )		


-- (>>=) Action sequencer and combiner :- read -> write -> read -> write -> ........
seqio :: PrologIO a -> (a -> PrologIO b) -> PrologIO b
--      (First action   (Take and perform                       
--      which generates  next action)
--      value a) 
seqio (PrologData a) 	f 	= f a
--seqio (Output o) 		f 	= \a -> o a
--seqio (Input i)    		f 	= \s -> (seqio (i s) f) --				Get (\s -> seqio (g s) f)



{--
instance Applicative PrologIO where
	func =

instance Traversable PrologIO where
	traverse f Empty 					= Empty
	traverse f (Input (IO a)) 			= Input (IO (f a))
	traverse f (Output (a -> IO ()))	= Output ((a) -> IO ())
	traverse f (PrologData a)			= PrologData (f a)
--}


concate :: PrologIO t -> PrologIO t -> IO ()
concate (Input f1) (Output f2) = do
	x <- f1
	f2 x
{--
concate (Input getLine) (Output putStrLn)
Loading package list-extras-0.4.1.4 ... linking ... done.
Loading package syb-0.5.1 ... linking ... done.
Loading package array-0.5.0.0 ... linking ... done.
Loading package deepseq-1.3.0.2 ... linking ... done.
Loading package containers-0.5.5.1 ... linking ... done.
Loading package transformers-0.4.3.0 ... linking ... done.
Loading package mtl-2.2.1 ... linking ... done.
Loading package logict-0.6.0.2 ... linking ... done.
Loading package unification-fd-0.10.0.1 ... linking ... done.
1
1
--}

\end{minted}

\end{document}
