\documentclass[thesis-solanki.tex]{subfiles}


\ifMain
\externaldocument{thesis-solanki}
\fi
\begin{document}

\chapter{Prototype 4}{\label{proto4}}


\section{What this chapter is about}

\noindent\rule{\textwidth}{0.5pt}
%-----------------------------------------------------------------------------

Our aim to embedd IO into the DSL

So something like a \yyy{"}{``}data\yyy{"}{''} declaration for IO operations

\section{I/O is pure}

\cite{website:ioispurechristaylor}

A common question amongst people learning Haskell is whether I/O is pure or not. Haskell advertises itself as a purely functional 
programming language, but I/O looks like it’s\eref{non-ascii} inherently impure - for example, the function getLine, which gets a line from stdin, returns 
a different result depending on what the user types:

\begin{minted}[linenos]{haskell}
Prelude> x <- getLine
Hello
Prelude> x
"Hello"
\end{minted}

How can this possibly be pure?

In this post I want to explain exactly why I/O in Haskell is pure. I’ll do it by building up data structures that represent blocks of code. 
These data structures can later be executed, and they cause effects to occur - but until that point we’ll always work with pure functions, 
never with effects.

Let’s look at a simplified form of I/O, where we only care about reading from stdin, writing to stdout and returning a value. We can model 
this with the \markWord{IOAction} data type.

That is, an \markWord{IOAction} is one of the following three things:
\begin{enumerate}
\item A container for a value of type \markWord{a},

\item A container holding a \markWord{String} to be printed to \markWord{stdout},
  followed by another \markWord{IOAction a}, or

\item A container holding a function from \markWord{String} \Verb!->! \markWord{IOAction a}, which can be applied
  to whatever \markWord{String} is read from \markWord{stdin}. 
\end{enumerate}

Notice that the only terminal constructor is \markWord{Return} –\endnote{%
  The preceding character is not an \textsc{ascii} character!
}
that means that any \markWord{IOAction} must be a combination of \markWord{Get} and \markWord{Put} constructors, 
finally ending in a \markWord{Return}.

Some simple actions include the one that prints to \markWord{stdout} before returning \Verb!()!:

\mint{haskell}|put s = Put s (Return ())|

and the action that reads from \markWord{stdin} and returns the string unchanged:

\mint{haskell}|get = Get (\s -> Return s)|

To build up a language for doing I/O we need to be able to combine and sequence actions. We want the ability to perform an \markWord{IOAction} \markWord{a} 
followed by an \markWord{IOAction} \markWord{b}, and return some result.

In fact, we could have the second \markWord{IOAction} depend on the return value of the first one -\endnote{%
  The preceding punctuation mark is incorrect.
}
that is, we need a sequencing combinator of the 
following type:

\mint{haskell}|seqio :: IOAction a -> (a -> IOAction b) -> IOAction b|

We want to take the \markWord{IOAction} \markWord{a} supplied in the first argument, get its return value (which is of type \markWord{a}) and feed that to the function in 
the second argument, getting an \markWord{IOAction} \markWord{b} out, which can be sequenced with the first \markWord{IOAction} \markWord{a}.

That’s a bit of a mouthful, but writing this combinator isn’t too hard. When we reach the final \markWord{Return}, we apply the function \markWord{f} to get a 
new action. For the other constructors, we keep the form of the action the same, and just thread seqio through the seqio constructor.

Using \markWord{seqio} we can define the action that gets input from \markWord{stdin} and immediately prints it to
the screen: 

%\mint{haskell}|echo = get $\backslash$ seqio $\backslash$ put|

or even more complicated actions:
\begin{minted}[linenos]{haskell}
hello = put "What is your name?"      `seqio` \_    ->
        get                           `seqio` \name ->
        put "What is your age?"       `seqio` \_    ->
        get                           `seqio` \age  ->
        put ("Hello " ++ name ++ "!") `seqio` \_    ->
        put ("You are " ++ age ++ " years old")
\end{minted}
Although this looks like imperative code (admittedly with pretty unpleasant syntax), it’s really a value of type \markWord{IOAction} \Verb!()!. In Haskell,\endnote{%
  Use \macroName{progLang}!
}
code can be data and data can be code.

In the gist\endnote{%
  The word ``\textit{gist}'' is an English word, but in this context you are using it for a meaning other than its
  natural English meaning.
  You'll need to explain this usage.
}
 I’ve defined a function to convert an \markWord{IOAction} to a \markWord{String}, which allows them to be printed, so you can load the file into \markWord{GHCi} 
and verify that \markWord{hello} is in fact just data:

\begin{minted}[linenos]{haskell}
*Main> print hello
Put "What is your name?" (
  Get ($0 -> 
    Put "What is your age?" (
      Get ($1 -> 
        Put "Hello $0!" (
          Put "You are $1 years old" (
            Return ()
          )
        )
      )
    )
  )
)
\end{minted}
It will surprise no one to learn that \markWord{IOAction} is a monad. In fact we’ve already defined the necessary bind operation in \markWord{seqio}, so getting 
the \markWord{Monad} instance is trivial:
\begin{minted}[linenos]{haskell}
instance Monad IOAction where
    return = Return
    (>>=)  = seqio
\end{minted}

The main benefit of doing this is that we can now sequence actions using Haskell’s\endnote{%
  Use \macroName{progLang}!
}
\markWord{do} notation, which desugars into calls to \Verb!(>>=)!, and 
hence to \markWord{seqio}. Our earlier \markWord{hello} example can now be written as:
\par
\begin{minted}[linenos]{haskell}
hello2 = do put "What is your name?"
            name <- get
            put "What is your age?"
            age <- get
            put ("Hello, " ++ name ++ "!")
            put ("You are " ++ age ++ " years old!")
\end{minted}
Remember though, that this is still just defining a value of type 
\markWord{IOAction} \Verb!()! -\endnote{%
  You want an em-dash, not a hyphen here.
}
no code is executed, and no effects occur! So far, this post is 100 \% pure.

To see the effects, we need to define a function that takes an \markWord{IOAction} \markWord{a} and converts it into a value of type \markWord{IO} \markWord{a}, which can then be executed by the interpreter or the runtime system. It’s easy to write such a function just by turning it into the approprate calls to \markWord{putStrLn} and \markWord{getLine}.

\begin{minted}[linenos]{haskell}
run :: IOAction a -> IO a
run (Return a) = return a
run (Put s io) = putStrLn s >> run io
run (Get g)    = getLine >>= \s -> run (g s)
\end{minted}

You can now load up \markWord{GHCi} and apply run to any action –\endnote{%
  The preceding character is not an \textsc{ascii} character!
}
a value of type \markWord{IO} \markWord{a} will be returned, and then immediately executed by the 
interpreter:

\begin{minted}[linenos]{haskell}
*Main> run hello
What is your name?
Chris
What is your age?
29
Hello Chris!
You are 29 years old

\end{minted}
Is there any practical use to this?

an \markWord{IOAction} is a mini-language for doing I/O. In this mini language you are restricted to only reading from \markWord{stdin} and writing to \markWord{stdout} -\endnote{%
  The preceding punctuation mark should be an em-dash.
}
there is no accessing files, spawning threads or network I/O.

In effect we have a “\endnote{%
  The preceding character is not an \textsc{ascii} character!
}
safe”\endnote{%
  The preceding character is not an \textsc{ascii} character!
} domain-specific language.
If a user of your program or library supplies a value of type \markWord{IOAction} \markWord{a}, you know that you are free to convert it to an \markWord{IO} \markWord{a} using run and execute it, 
and it will never do anything except reading from \markWord{stdin} and writing to \markWord{stdout} (not that those things aren’t potentially dangerous in themselves, but…\endnote{%
  The preceding character is not an \textsc{ascii} character!
  
})


\begin{singlespace}
  \inputminted[linenos]{haskell}{haskell-proto4-purvey-wincer.hs}
\end{singlespace}

\section{Dr. Casperson Pure IO}
\begin{singlespace}
  \inputminted[linenos]{haskell}{haskell-proto4-myrtle-uppers.hs}
\end{singlespace}

\section{Mehul Pure IO}

So when the program is getting interpreted the interpreter encounters an IO operation which then gets "interpreted" to the above and it 
continues normally.

The interpreted program is still pure since the IO actions have not been executed 

if the running is done inside a monad then the IO still is pure.


\begin{singlespace}
  \inputminted[linenos]{haskell}{haskell-proto4-platen-winkel.hs}
\end{singlespace}


\section{Chapter Recapitulation}

\ifMain
\begin{scope}
  \nolinenumbers
  \enotesize
  \par
  \begin{singlespace}
  \setlength{\parskip}{12pt plus 2pt minus 1pt}
  \theendnotes
  \par
  \end{singlespace}
\end{scope}
\unbcbibliography{bibliography}
\fi

\end{document}
