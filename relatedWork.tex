\documentclass[proposal.tex]{subfiles}



\begin{document}


% ---------------------------------------------------------------------------
\chapter{Related Concepts}\label{chap:relatedWork}
% ---------------------------------------------------------------------------


\section{What this chapter is about}

\noindent\rule{\textwidth}{0.5pt}
%-----------------------------------------------------------------------------


There are some technicalities which are indirectly related to the problem but do not bare a point of contact.
The underpinnings of the languages throw some more light on the how different languages work to solve a problem.
Different programming paradigms incorporate different operational mechanisms.
For example, \progLang{Prolog} programs execute on the Warren Abstract Machine \cite{ait1999warren} which has three
different storage usages; a global stack for compound terms, for environment frames and choice points and lastly
the trail to record which variables bindings ought to be undone on backtracking.

Constraint programming \cite{website:constraintprogwiki} is closely related to the declarative programming paradigm
in the sense that the relations between variables is specified in the form of constraints.
For example, consider a program to solve a simultaneous equation, now adding on to that restricting the range of
the values that the variables can possible take, thus adding constraints to the possible solutions.
Related to the same are constraint handling rules \cite{website:chrwiki}, which are extensions to a language,
simply speaking adding constraints to a language like \progLang{Prolog}.

Lastly some details on the working of functional logic programming languages, residuation and narrowing
\cite{hanus1995curry,webiste:wikicurry}.
Residuation involves delaying of functions calls until they are deterministic, that is, deterministic reduction of
functions with partial data.
This principle is used in languages like \progLang{Escher} \cite{lloyd1999programming:escher}, \progLang{Life}
\cite{website:life}, \progLang{NUE-Prolog} \cite{website:nue-prolog} and \progLang{Oz} \cite{website:oz-mozart}.
Narrowing on the other hand is a mixture of reduction in functional languages and unification in logic languages.
In narrowing, a variable is bound a value within the specified constraints and try to find a solution, values are
generated while searching rather than just for testing.
The languages based on this approach are \progLang{ALF} \cite{website:alf}, \progLang{Babel} \cite{website:babel},
\progLang{LPG} \cite{bert1987lpg} and \progLang{Curry} \cite{website:curry}.


F-Algebras


We are now ready to define \markWord{F}-algebras in the most general terms.
First I'll use the language of category theory and then quickly translate it to \progLang{Haskell}.

An \markWord{F}-algebra consists of:
\begin{enumerate}
\item an endofunctor \markWord{F} in a category \markWord{C},
\item an object \markWord{A} in that category, and
\item a morphism from \markWord{F(A)} to \markWord{A}.
\end{enumerate}

An \markWord{F}-algebra in \progLang{Haskell} is defined by a functor \markWord{f}, a carrier type \markWord{a}, and a function from \markWord{(f a)} to \markWord{a}. (The underlying category is \markWord{Hask}.)

Right about now the definition with which I started this post should start making sense:

\mint{haskell}|type Algebra f a = f a -> a|

For a given functor \markWord{f} and a carrier type \markWord{a} the algebra is defined by specifying just one function.
Often this function itself is called the algebra, hence my use of the name alg in previous examples.


\section{Monads by example: The State Monad}




\section{Chapter Recapitulation}


\end{document}
