\documentclass[proposal.tex]{subfiles}



\begin{document}


% ---------------------------------------------------------------------------
\chapter{Related Concepts}\label{chap:relatedWork}
% ---------------------------------------------------------------------------


\section{What this chapter is about}

\noindent\rule{\textwidth}{0.5pt}
%-----------------------------------------------------------------------------


There are some technicalities which are indirectly related to the problem but do not bare a point of contact.
The underpinnings of the languages throw some more light on the how different languages work to solve a problem.
Different programming paradigms incorporate different operational mechanisms.
For example, \progLang{Prolog} programs execute on the Warren Abstract Machine \cite{ait1999warren} which has three
different storage usages; a global stack for compound terms, for environment frames and choice points and lastly
the trail to record which variables bindings ought to be undone on backtracking.

Constraint programming \cite{website:constraintprogwiki} is closely related to the declarative programming paradigm
in the sense that the relations between variables is specified in the form of constraints.
For example, consider a program to solve a simultaneous equation, now adding on to that restricting the range of
the values that the variables can possible take, thus adding constraints to the possible solutions.
Related to the same are constraint handling rules \cite{website:chrwiki}, which are extensions to a language,
simply speaking adding constraints to a language like \progLang{Prolog}.

Lastly some details on the working of functional logic programming languages, residuation and narrowing
\cite{hanus1995curry,webiste:wikicurry}.
Residuation involves delaying of functions calls until they are deterministic, that is, deterministic reduction of
functions with partial data.
This principle is used in languages like \progLang{Escher} \cite{lloyd1999programming:escher}, \progLang{Life}
\cite{website:life}, \progLang{NUE-Prolog} \cite{website:nue-prolog} and \progLang{Oz} \cite{website:oz-mozart}.
Narrowing on the other hand is a mixture of reduction in functional languages and unification in logic languages.
In narrowing, a variable is bound a value within the specified constraints and try to find a solution, values are
generated while searching rather than just for testing.
The languages based on this approach are \progLang{ALF} \cite{website:alf}, \progLang{Babel} \cite{website:babel},
\progLang{LPG} \cite{bert1987lpg} and \progLang{Curry} \cite{website:curry}.


F-Algebras


We are now ready to define \markWord{F}-algebras in the most general terms.
First I'll use the language of category theory and then quickly translate it to \progLang{Haskell}.

An \markWord{F}-algebra consists of:
\begin{enumerate}
\item an endofunctor \markWord{F} in a category \markWord{C},
\item an object \markWord{A} in that category, and
\item a morphism from \markWord{F(A)} to \markWord{A}.
\end{enumerate}

An \markWord{F}-algebra in \progLang{Haskell} is defined by a functor \haskellConstruct{f}, a carrier type \markWord{a}, and a function from \markWord{(f a)} to \markWord{a}. (The underlying category is \haskellConstruct{Hask}.)

Right about now the definition with which I started this post should start making sense:

\mint{haskell}|type Algebra f a = f a -> a|

For a given functor \haskellConstruct{f} and a carrier type \markWord{a} the algebra is defined by specifying just one function.
Often this function itself is called the algebra, hence my use of the name alg in previous examples.


\section{Monads by example: The State Monad}


\begin{code-list}[H]
  \begin{singlespace}
    \inputminted[linenos, firstline=16, lastline=33]{haskell}{haskell-monad-working-2.hs}
  \end{singlespace}
  \caption{Haskell Monad Working: Data Types}
\label{tab:hskllmndworkngdatatype}
\end{code-list}

\begin{code-list}[H]
  \begin{singlespace}
    \inputminted[linenos, firstline=35, lastline=65]{haskell}{haskell-monad-working-2.hs}
  \end{singlespace}
  \caption{Haskell Monad Working: Functions 1}
\label{tab:hskllmndworkngfunctions}
\end{code-list}

\begin{code-list}[H]
  \begin{singlespace}
    \inputminted[linenos, firstline=60, lastline=94]{haskell}{haskell-monad-working-2.hs}
  \end{singlespace}
  \caption{Haskell Monad Working: Functions 2}
\label{tab:hskllmndworkngfunctions}
\end{code-list}

\begin{code-list}[H]
  \begin{singlespace}
    \inputminted[linenos, firstline=97, lastline=123]{haskell}{haskell-monad-working-2.hs}
  \end{singlespace}
  \caption{Haskell Monad Working: Examples}
\label{tab:hskllmndworkngexamples}
\end{code-list}


\section{The execution model of \progLang{Prolog} \cite{Sterling:1994:APA:175753}}
Two major decisions must be taken for \progLang{Prolog} to resolve a query:
\begin{enumerate}
\item Scheduling policy

Select leftmost goal and replace the non deterministic choice of a clause by sequential search for a unifiable clause and backtracking.

Stack scheduling policy, pop the topmost goal for reduction and push derived goals back.

\item Search strategy

\progLang{Prolog} simulates the non-deterministic choice of reducing clause by sequential search and backtracking. 

The first goal whose head unifies with the goal is chosen. If no match is found then the computation is unwound to the last choice point and
the next unifiable clause is chosen.
\end{enumerate}

\progLang{Prolog} generates all possible solutions of the goal with respect to the \progLang{Prolog} program. It performs a complete
depth first traversal of a particular search tree for the goal by always choosing the leftmost goal. Listing~\ref{tab:prlgprgrmtrce} shows
a sample trace for a query.

\begin{code-list}[H]
  \begin{singlespace}
    \inputminted[linenos]{prolog}{prologprogramtrace.pl}
  \end{singlespace}
  \caption{Tracing a simple Prolog computation \cite{Sterling:1994:APA:175753}}
\label{tab:prlgprgrmtrce}
\end{code-list}



\section{Chapter Recapitulation}


\end{document}
