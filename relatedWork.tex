\documentclass[proposal.tex]{subfiles}



\begin{document}


% ---------------------------------------------------------------------------
\chapter{Related Concepts}\label{chap:relatedWork}
% ---------------------------------------------------------------------------


\section{About this chapter}
This chapter discusses concepts which are related to the work presented in this thesis which may no bear a direct point of contact but 
contribute to understanding. 

\section{Map-reduce}

\textit{MapReduce} is a programming model and an associated implementation for processing and generating large data sets. Users specify a 
map function that processes a key/value pair to generate a set of intermediate key/value pairs, and a reduce function that merges all 
intermediate values associated with the same intermediate key \cite{dean2008mapreduce}.

In \progLang{Haskell} it is implemented using the \haskellConstruct{map} and \haskellConstruct{fold} functions. 
\haskellConstruct{map} takes as arguments: an operation and a list of values, and applies the operation to each element in the list. 
The \haskellConstruct{map}
operation is as follows:

\mint{haskell}|map (+3) [1,5,3,1,6]|

and results in
\mint{haskell}|[4,8,6,4,9]|

\haskellClass{fold} takes as arguments: an operation, an accumulator and a list, and applies the operation on the accumulator and each 
element one at a time till the end of the list and returns the final accumulator.

The \haskellClass{fold} operation is as follows:

\mint{haskell}|foldr (+) 0 [4,8,6,4,9]|

and results in,

\mint{haskell}|31|
 

\section{Type systems}

A type system consists of a set of rules to define a ``type'' to different constructs in a
programming language such as variables, functions and so on.
A static type system requires types to be attached to the programming constructs before hand which results in
finding errors at compile time and thus increase the reliability of the program.
On the other hand the dynamic type system passes through code which would not have worked in former
environment; it comes off as less rigid.


The advantages of static typing \cite{meijer2004static} are :
\begin{itemize}
\item earlier detection of errors,
\item better documentation in terms of type signatures,
\item more opportunities for compiler optimizations,
\item increased run-time efficiency, and
\item better developer tools;
\end{itemize}

whereas for dynamic typing the advantages are:
\begin{itemize}
\item less rigidity,
\item suitability, and
\item re-usability.
\end{itemize}

\section{Warren abstract machine}
There are some technicalities which are indirectly related to the problem but do not bare a point of contact.
The underpinnings of the languages throw some more light on the how different languages work to solve a problem.
Different programming paradigms incorporate different operational mechanisms.
For example, \progLang{Prolog} programs execute on the Warren Abstract Machine \cite{ait1999warren} which has three
different storage usages; a global stack for compound terms, for environment frames and choice points and lastly
the trail to record which variables bindings ought to be undone on backtracking.

\section{Residuation and narrowing}
Lastly some details on the working of functional logic programming languages, residuation and narrowing
\cite{hanus1995curry,webiste:wikicurry}.
Residuation involves delaying of functions calls until they are deterministic, that is, deterministic reduction of
functions with partial data.
This principle is used in languages like \progLang{Escher} \cite{lloyd1999programming:escher}, \progLang{Life}
\cite{website:life}, \progLang{NUE-Prolog} \cite{website:nue-prolog} and \progLang{Oz} \cite{website:oz-mozart}.
Narrowing on the other hand is a mixture of reduction in functional languages and unification in logic languages.
In narrowing, a variable is bound a value within the specified constraints and try to find a solution, values are
generated while searching rather than just for testing.
The languages based on this approach are \progLang{ALF} \cite{website:alf}, \progLang{Babel} \cite{website:babel},
\progLang{LPG} \cite{bert1987lpg} and \progLang{Curry} \cite{website:curry}.

%% dgc : The [] in the section heading avoids having the reference show
%% up in the table of contents.  
\section{Meta syntactic variables}
\mehul{needs to be compressed into a single short explanation}


\cite{website:metasyntacticvariableswiki}
A metasyntactic variable is a placeholder name used in computer science, a word without meaning intended to be
substituted by some objects pertaining to the context where it is used.

The word \markWord{foo} as used in IETF Requests for Comments is a good example.\endnote{%
  This regards
  \vspace*{-1.5\baselineskip}
  \begin{quote}\itshape
    A metasyntactic variable is a placeholder name used in computer science, a word without meaning intended to be
    substituted by some objects pertaining to the context where it is used. 
    The word \textsf{foo} as used in IETF Requests for Comments is a good example.
  \end{quote}
  \vspace*{-1.5\baselineskip}
  Some comments
  \begin{compactitem}
  \item
    ``IETF'' needs explanation.
  \item
    Because it is a something other than an English word with its ordinary meaning, ``foo'' needs to be marked
    up.
  \item
    The claim is overly broad.  In ``\texttt{\bfseries cat foo > bar}'', the word
    ``\texttt{\bfseries foo}'' is a file-name variable; it may be replaced by any file name
    (appropriately quoted for the surrounding shell).
    It is only when the variable ranges over syntax of an appropriate that the variable is metasyntactic.  For
    instance in ``\texttt{3 + 5 * }\textsf{term}'' the word ``\textsf{term}'' is a metasyntactic variable, the
    remainder is presumably either concrete or abstract syntax.
  \end{compactitem}
}

By mathematical analogy, a metasyntactic variable is a word that is a variable for other words, just as in algebra
letters are used as variables for numbers.
Any symbol or word which does not violate the syntactic rules of the language can be used as a metasyntactic
variable.




\cite{webiste:metasyntacticvariablescatb}
A name used in examples and understood to stand for whatever thing is under discussion, or any random member of a class of things under discussion. The word foo is the canonical example. To avoid confusion, hackers never (well, hardly ever) use `foo'\endnote{%
  This particular instance fixed.
  Avoid non-\textsc{ascii} characters.  Left single quote (u\(+\)x2018) should be entered in files as a grave
  accent (u\(+\)x60), and right single quote (u\(+\)x2019) as a plain single quote (0x27).

  Similarly, left double quote (u\(+\)x201c) should be entered as two grave accents, and right double quote as two
  single quotes.

  Em-dashes (u\(+\)x2014)---used to separate thoughts inside sentences---are typed as three minus signs.

  En-dashes (u\(+\)x2013), used to separate numbers, for instance 3--5, are typed as two minus signs.
}\elabel{non-ascii}
or other words like it as permanent names for anything. In filenames, a common convention is that any filename beginning with a metasyntactic-variable name is a scratch file that may be deleted at any time.

Metasyntactic variables are so called because they are variables in the metalanguage used to talk about programs
etc; they are variables whose values are often variables (as in usages like ``the value of f(foo,bar) is
the sum of foo and bar'').
However, it has been plausibly suggested that the real reason for the term ``metasyntactic
variable'' is that it sounds good.
To some extent, the list of one's preferred metasyntactic variables is a cultural signature.
They occur both in series (used for related groups of variables or objects) and as singletons.
Here are a few common signatures:


\cite{webiste:metasyntacticvariableswhatistectarget}
In programming, a metasyntactic (which derives from meta and syntax ) variable is a variable (a changeable value) that is used to temporarily represent a function . Examples of metasyntactic variables include (but are by no means limited to) ack, bar , baz, blarg, wibble, foo , fum, and qux. Metasyntactic variables are sometimes used in developing a conceptual version of a program or examples of programming code written for illustrative purposes.

Any filename beginning with a metasyntactic variable denotes a scratch file. This means the file can be deleted at any time without affecting the program.



\cite{webste:metasyntacticvariablesc2wiki}

A word, used in conversation or text that is meant as a variable. There is a fairly standard set in the Computer Science
culture. People tend to create their own if they are not exposed to others, which can be confusing. Of course, if you haven't seen them before they can be quite confusing. They are, however, useful enough that this is not enough reason to give them up.
Standard set: foo, bar, baz, foobar/quux, quuux, quuuux, ....

example: ``Suppose I have a list, foo, with a node, bar, ...''


\section{Chapter recapitulation}
Recapitulating, this chapter described the concepts loosely related to the thesis but do not bare a direct point of contact for better 
understanding.

\end{document}
