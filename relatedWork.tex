\documentclass[proposal.tex]{subfiles}



\begin{document}


% ---------------------------------------------------------------------------
\chapter{Related Concepts}\label{chap:relatedWork}
% ---------------------------------------------------------------------------


\section{About this chapter}
This chapter discusses concepts which are related to the work presented in this thesis which may not bear a direct
point of contact but contribute to understanding.

\section{Map-reduce}

\textit{MapReduce} is a programming model and an associated implementation for processing and generating large data
sets.
Users specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs, and
a reduce function that merges all intermediate values associated with the same intermediate key
\cite{dean2008mapreduce}.

In \progLang{Haskell} it is implemented using the \haskellConstruct{map} and \haskellConstruct{fold} functions.
\haskellConstruct{map} takes as arguments: an operation and a list of values, and applies the operation to each
element in the list.
The \haskellConstruct{map} operation is as follows:

\mint{haskell}|map (+3) [1,5,3,1,6]|

\noindent and results in
\mint{haskell}|[4,8,6,4,9]|

\noindent \haskellClass{fold} takes as arguments: an operation, an accumulator and a list, and applies the operation on the
accumulator and each element one at a time till the end of the list and returns the final accumulator.

The \haskellClass{fold} operation is as follows:

\mint{haskell}|foldr (+) 0 [4,8,6,4,9]|

\noindent and results in,

\mint{haskell}|31|
 

\section{Type systems}

A type system consists of a set of rules to define a ``type'' to different constructs in a
programming language such as variables, functions and so on.
A static type system requires types to be attached to the programming constructs before hand which results in
finding errors at compile time and thus increase the reliability of the program.
On the other hand the dynamic type system passes through code which would not have worked in former
environment; it comes off as less rigid.


The advantages of static typing \cite{meijer2004static} are :
\begin{itemize}
\item earlier detection of errors,
\item better documentation in terms of type signatures,
\item more opportunities for compiler optimizations,
\item increased run-time efficiency, and
\item better developer tools;
\end{itemize}

whereas for dynamic typing the advantages are:
\begin{itemize}
\item less rigidity,
\item suitability, and
\item re-usability.
\end{itemize}

\section{Residuation and narrowing}
Lastly some details on the working of functional logic programming languages, residuation and narrowing
\cite{hanus1995curry,webiste:wikicurry}.
Residuation involves delaying of function calls until they are deterministic, that is, deterministic reduction of
functions with partial data.
This principle is used in languages like \progLang{Escher} \cite{lloyd1999programming:escher}, \progLang{Life}
\cite{website:life}, \progLang{NUE-Prolog} \cite{website:nue-prolog} and \progLang{Oz} \cite{website:oz-mozart}.
Narrowing on the other hand is a mixture of reduction in functional languages and unification in logic languages.
In narrowing, a variable is bound a value within the specified constraints and try to find a solution, values are
generated while searching rather than just for testing.
The languages based on this approach are \progLang{ALF} \cite{website:alf}, \progLang{Babel} \cite{website:babel},
\progLang{LPG} \cite{bert1987lpg} and \progLang{Curry} \cite{website:curry}.

%% dgc : The [] in the section heading avoids having the reference show
%% up in the table of contents.  

\section{Summary}
Recapitulating, this chapter described the concepts loosely related to the thesis but do not bare a direct point of
contact for better understanding.

\end{document}
