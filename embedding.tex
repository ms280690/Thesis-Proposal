\documentclass[thesis-solanki.tex]{subfiles}

\ifMain
\externaldocument{thesis-solanki}
\fi
\begin{document}


\chapter{Embedding a Programming Language into another Programming Language }\label{chap:embedding}


\section{What this chapter is about}

The art of embedding a programming language into another one has been explored a number of times in the form of
building libraries or developing foreign function interfaces and so on.
This area mainly aims at an environment and setting where two or more languages can work with each other
harmoniously with each one able to play a part in solving the problems in the domain.
This chapter mainly reviews the content related to embedding \progLang{Prolog} in \progLang{Haskell} but also
includes information on some other implementations and embedding languages in general.
%Embedding a programming language into another, in this we talk about embedding Prolog in Haskell.
%The following are the sources or related work that can be found,


\section{The Informal Content from Blogs, Articles and Internet Discussions}

Before moving on to the formal content such as publications, modules and libraries, let's take a look
at some of the unofficially published content.
This subsection takes a look at the information, thoughts and discussions that are currently taking place from time
to time on the internet.
A lot of interesting content is generated which has often led to some formal content.

A lot has been talked about embedding languages and also the techniques and methods to do so.
It might not seem such a hot topic as such but it has always been a part of any programming language to work and
integrate their code with other programming languages.
One of the top discussions are in, Lambda the Ultimate, The Programming Languages Weblog
\cite{website:lambda-the-ultimate} lists a number of \progLang{Prolog} implementations in a variety of languages
like \progLang{Lisp, Scheme, Scala, Java, Javascript}, \progLang{Racket} \cite{racklog} and so on.
Moreover the discussion focuses on a lot of critical points that should be considered in a translation of
\progLang{Prolog} to the host language in terms of types and modules among others.

One of the implementations discussed redirects us to one of the earliest implementations of \progLang{Prolog} in
\progLang{Haskell} for \haskellConstruct{Hugs 98}, called \haskellConstruct{Mini} \progLang{Prolog}
\cite{website:mini-prolog-hugs98}.
Although this implementation takes as reference the working of the \progLang{ Prolog} Engine\endnote{%
  \david{What does the \cite{website:mini-prolog-hugs98} implementation takes as reference?
    Is it based on the Warren Abstract Machine?
    Some other formal specification of \progLang{Prolog}?
  }
}
and other details, it still is an unpublished implementation with almost no documentation, support  or ongoing
development.
Moreover, it comes with an option of three engines to play
with, but still lacks complete list support\endnote{%
  \david{What is list support?  What is complete list support?  You have not
  defined either of these terms.}\newline
  \mehul{I forgot}.\newline
  \mehul{i remembered. All the different types of data types in
    \progLang{Prolog} are uni type just like our abstract syntax
    language.}\newline
  \david{Are you saying that you want lists in \progLang{Prolog} to be constructed from something other than
    the \progLang{Prolog} functors equivalent to \progLang{Haskell}'s ``\texttt{\bfseries :}'' and
    ``\texttt{\bfseries []}''?  I think that that has far reaching consequences.}
}
and quite a few of practical features that \progLang{Prolog} has.
This seems to be a common problem with the other implementation that exists, \cite{website:takashi-workplace}.

Adding fuel to fire, is the question on \progLang{Prolog}'s existence and survival
\cite{website:prolog-killer,website:prolog-steam,website:prolog-death,somogyi1995logic} since its use in industry
is minimal in comparison with the languages of imperative nature.
The purely declarative nature lacks basic requirements such as support for \languageConstruct{modules}.\endnote{%
  \david{Do you mean that basic \progLang{Prolog} implementations lack modules;
  or that \progLang{Prolog} lacks \languageConstruct{modules} because it is purely
  declarative; or \dots?}\newline
  \mehul{I do not know about the paradigm, but \progLang{Prolog} language having a declarative nature lacks
    modules{\Huge.}}\newline
  \david{I do not see the incompatibility between declarative languages and modules.}
}
The other issue is the ongoing comparison between the siblings \cite{website:haskell-choice} of the same family, the
family of declarative languages.\endnote{%
  \david{What does this sentence mean?
  Are you suggesting that one of \progLang{Prolog}'s problems is that it is
  competing with \progLang{Haskell}?
  }\par
  \mehul{
  \progLang{Haskell} has advantages over \progLang{Prolog} despite being from the same paradigm
  \newline
  So a choice has to be made for a declarative language why not \progLang{Haskell} ?}

  \david{Then say something like
    ``\textsl{Another issue raised by ongoing informal discussions are unflattering comparison between siblings
      \cite{website:haskell-choice}.
      This makes potential users question the choice of \progLang{Prolog},
      when \progLang{Haskell}---also a language in the family of declarative languages---is so popular.}''
    I am not sure if I have that sentence exactly right, but you need to be more explicit about the argument.
  }
}
Not to forget \progLang{Haskell} also has some support for logic programming \cite{website:logic-programming-haskell} which
enables encoding of search problems.\endnote{%
  This preceding phrase is not a sentence.
	\mehul{changed}
}\elabel{not-a-sentence} \mehul{changed}

\section{Books related to embedding Programming Languges}

As \progLang{Haskell} is relatively new in terms of being popular, its predecessors such as \progLang{Scheme} have
explored the territory of embedding  quite profoundly \cite{friedman05reasoned}, which aims at adding a few
constructs to the language to bring together both styles of declarative programming and capture the essence of
\progLang{Prolog}.
Moreover, \progLang{Haskell} also claims for it to be suitable for basic logic programming naturally using the
\haskellConstruct{List Monad} \cite{website:logicprogexamplehaskell}.
A general outlook towards implementing \progLang{Prolog} has also been discussed by
\cite{krishnamurthi2007programming} to push the ideas forward.\endnote{%
  This \P{} needs a lot of work.
  I do not understand what you say the references say.
}

\section{Papers related to embedding Programming Languges}

Abundant literature can be found on embedding detailed parts of \progLang{Prolog} features such as basic
constructs, search strategies and data types.
One of the major works is covered by the subsection below consisting of a series of papers from Mike Spivey and
Silvija Seres aimed at bring \progLang{Haskell} and \progLang{Prolog} closer to each other.
The next subsection covers the literature based on the above\endnote{%
  I am not sure what ``the above'' refers to here: \cite{spivey1999embedding}?.
\mehul{you mean below?}
}
with improvements and further additions.


\subsection{Papers from Mike Spivey and Silvija Seres}


The work presented in the series
\cite{spivey1999embedding,seres1999algebra,seres2001higher,spivey1999algebra,seres2001algebra} attempts to
encapsulate various aspects of an embedding of \progLang{Prolog} in \progLang{Haskell}.
Being the very first documented formal attempt, the work is influenced by similar embeddings of \progLang{Prolog}
in other languages like \progLang{Scheme} and \progLang{Lisp}.
Although the host language has distinct characteristics such as lazy evaluation and strong type system the proposed
scheme tends to be general as the aim here is to achieve \progLang{Prolog}-like working not a multiparadigm
declarative language.
\progLang{Prolog} \prologConstruct{predicates} are translated to \progLang{Haskell} functions which produce a
stream of results lazily depicting depth first search with support for different strategies and practical operators
such as \prologConstruct{cut} and \prologConstruct{fail} with higher order functions.
The papers provide a minimalistic extension to \progLang{Haskell} with only four new constructs.
Though no implementation exists, the synthesis and transformation techniques for functional programs have been
\textit{logicalised} and applied to \progLang{Prolog} programs.
Another related work \cite{spivey2000functional} looks through conventional data types so as to adapt to the
problems in the domain\endnote{%
  I still don't understand what problems we are talking about here.
} and accommodate and jump between search strategies.


\subsection{Other works related or based on the above}

%\par This section takes a look at the improvements at the attempts mostly based on the work from the previous section. Some work is done by the one of the authors above while the other prominent others in the same field.

Continuing from above, \cite{claessen2000typed} taps into the advantages of the host language to embed a typed
functional logic programming language.
This results in typed logical predicates and a backtracking \haskellConstruct{monad} with support for various data
types and search strategies.
Though not very efficient nor practical,
the method aims at a more elegant translation of programs from one language
to the other.
While other papers \cite{erwig2004escape} attempt at exercising \progLang{Haskell} features without adding
anything new.\endnote{%
    This is a sentence fragment.
  }\elabel{sentence-fragment} \mehul{changed}
Specifically speaking, using \progLang{Haskell}'s type class to express general structure of a problem while the
solutions are instances.\eref{sentence-fragment}\textsuperscript{,}\endnote{%
    I do not understant the preceding sentence.

  }
\cite{hinze1998prological} replicates \progLang{Prolog}'s control operations in \progLang{Haskell} suggesting the
use of the \progLang{Haskell} \haskellConstruct{State Monad} to capture and maintain a global state.
The main contributions are a Backtracking Monad Transformer that can enrich any \haskellConstruct{monad} with
backtracking abilities and a \haskellConstruct{monadic encapsulation} to turn a \progLang{Prolog} predicate into a
\progLang{Haskell} function.



\section{Related Libraries in Haskell}
%\begin{description}
%\item[$\bullet$]\endnote{%
%%   See the preceding comments about using \texttt{itemize} rather than \texttt{description}.
%%   Maybe these should be subsections.
%% }
\subsection{Prolog Libraries}

To replicate \progLang{Prolog}-like
capabilities \progLang{Haskell} seems to be a popular choice
with a host of related libraries.
First we begin with the libraries about Prolog\endnote{%
  Naked Prolog.
}
itself.
A few exist\yyy{}{\Huge.} \cite{nanoprolog-lib} \yyy{being}{is} a preliminary or
``mini \progLang{Prolog}'' \xxx{as such} with not much in it to be able to be useful. \cite{hswip-lib}
is all powerful\yyy{}{\Large,} but is a foreign function interface so it is ``\progLang{Prolog} in \progLang{Haskell}'' but we
need \progLang{Prolog} for it;
\cite{prolog-lib}
is the implementation that comes the closest
to something like an actual practical \progLang{Prolog}.
All these libraries provide is a small interpreter, none or a few practical features, incomplete support for lists, minor or
no \haskellConstruct{monadic} support and a REPL without the ability to ``write a \progLang{Prolog} program
file''.

%\item[$\bullet$]Logic Libraries
\subsection{Logic Libraries}

The next category is about the logical aspects of \progLang{Prolog}; again a handful of libraries provide
functionality related to propositional logic and backtracking.
\cite{logict-lib} is a continuation-based, backtracking, logic programming \haskellConstruct{monad} which attempts
to replicate
\progLang{Prolog}'s backtracking behaviour.
\progLang{Prolog} is heavily based on formal logic.
\cite{proplogic-lib} provides a powerful system for propositional logic.
Other libraries include small hybrid languages \cite{cflp-lib} and ``Parallelising Logic Programming and Tree
Exploration'' \cite{logic-grows-on-trees-lib}.


%\item[$\bullet$]Unification Libraries
\subsection{Unification Libraries}

The more specific the feature, the lesser the support in \progLang{Haskell}.
Moving on to the other feature of \progLang{Prolog} is \prologConstruct{unification}.\endnote{%
  ``Moving on to the other distinct feature of Prolog is Unification.''?  Say it aloud.
  \mehul{changed}
}
There are two libraries (\cite{unification-fd-lib}, \cite{cmu-lib}) that unify two \progLang{Prolog} terms and return
the resulting substitution.


%\item[$\bullet$]Backtracking
\subsection{Backtracking}

Another important aspect of \progLang{Prolog} is backtracking.
To simulate it in \progLang{Haskell}, the libraries \cite{stream-monad-lib, logicst-lib} use \haskellConstruct{monads}.
Moreover, there is a package for the \progLang{Egison} programming language \cite{egison-lib} which supports
non-linear pattern-matching with backtracking.


%% \end{description}


\section{Chapter Recapitulation}
Recapitulating, this chapter surveys the approach to embedding programming languages, especially \progLang{Prolog} in \progLang{Haskell}.
Moreover, it provides tools, some of which are utilized in the prototype implementation.   

\ifMain
\begin{scope}
  \nolinenumbers
  \enotesize
  \par
  \begin{singlespace}
  \setlength{\parskip}{12pt plus 2pt minus 1pt}
  \theendnotes
  \par
  \end{singlespace}
\end{scope}
\unbcbibliography{bibliography}
\fi

\end{document}
