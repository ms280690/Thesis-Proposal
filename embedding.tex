
\documentclass[thesis-solanki.tex]{subfiles}

\begin{document}


\section{What is this chapter about}

-----------------------------------------------------------------------------

\chapter{Embedding a Programming Language into another Programming Language }\label{chap:embedding}

The art of embedding a programming language into another one has been explored a number of times in the form
of building libraries or developing Foreign Function Interfaces and so on. This area mainly aims at an environment
and setting where two or more languages can work with each other harmoniously with each one able to play a part
in solving the problem at hand. This chapter mainly reviews the content related to embedding \progLang{Prolog} in
\progLang{Haskell} but also includes information on some other implementations and embedding languages in
general.
%Embedding a programming language into another, in this we talk about embedding Prolog in Haskell.
%The following are the sources or related work that can be found,


\section{The Informal Content from Blogs, Articles and Internet Discussions}

Before moving on to the formal content such as publications, modules and libraries let's take a look at some of the
unofficially published content.
This subsection takes a look at the information, thoughts and discussions that are currently taking place from time
to time on the internet.
A lot of interesting content is generated which has often led to some formal content.

A lot has been talked about embedding languages and also the techniques and methods to do so.
It might not seem such a hot topic as such but it has always been a part of any programming language to work and
integrate their code with other programming languages.
One of the top discussions are in, Lambda the Ultimate, The Programming Languages Weblog
\cite{website:lambda-the-ultimate},  which lists a number of \progLang{Prolog} implementations in a variety of
languages like \progLang{Lisp, Scheme, Scala, Java, Javascript}, \progLang{Racket} \cite{racklog} and so on.
Moreover the discussion focusses on a lot of critical points that should be considered in a translation of
\progLang{Prolog} to the host language regarding types and modules among others.

One of the implementations discussed redirects us to one of the most earliest implementations of \progLang{Prolog}
in \progLang{Haskell} for Hugs 98, called Mini \progLang{Prolog} \cite{website:mini-prolog-hugs98}.
Although this implementation takes as reference the working of the \progLang{ Prolog} Engine and other details, it
still is an unofficial implementation with almost no documentation, support  or ongoing development.
Moreover, it comes with an option of three engines to play with but still lacks complete list support and a lot of
practical features that \progLang{Prolog} has and this seems to be a common problem with the only other
implementation that exists, \cite{website:takashi-workplace}.

Adding fuel to fire, is the question on \progLang{Prolog}'s existence and survival
\cite{website:prolog-killer,website:prolog-steam,website:prolog-death,somogyi1995logic} since its use in industry
is far scarce than the leading languages of other paradigms.
The purely declarative nature lacks basic requirements such as support for modules.
And then there is the ongoing comparison between the siblings \cite{website:haskell-choice} of the same family, the
family of Declarative Languages.
Not to forget \progLang{Haskell} also has some tricks \cite{website:logic-programming-haskell} up its sleeve which
enables encoding of search problems.

\begin{comment}
	\begin{enumerate}

	\item Lambda The Ultimate, The Programming Languages Weblog,
	\\* \url{http://lambda-the-ultimate.org/node/112}

	\item Takashi's Workplace (Implementation),
	\\* \url{http://propella.blogspot.in/2009/04/prolog-in-haskell.html}

	\item Mini Prolog for Hugs 98 (Implementation), \cite{website:mini-prolog-hugs98}
	\\*The first attempt at embedding Prolog in Haskell, there is not documentation as such. No paper was published either, it was just another unofficial attempt at replicating Prolog implementations in other languages like Lisp, Scheme etc. Again it is labelled to be a ''Mini Prolog'' and was riginally made for Hugs 1.3 and then updated for Hugs 98. Hugs is not active in development anymore, the last release was for 2006 and mostly everything these days is in GHC/GHCi. The special libraries and other Haskell files are required to run it. So not exactly ''new'' and also  not ''happening'' anymore.

	Thsi implementation is a complex, because it deals with a lot literature and all of how Prolog Engine works,  called Andorra Prolog.

	There is nothing such as out traditional list data structure in the form we know it. We cannot use something like [1,2,3] we have to forcible use, (Cons 1 (Cons 2 (Cons 3 nil))).  There are three engines, Lazy Engine(Pure Engine), Andorra Engine and Stack Engine. The Lazy engine can construct and traverse infinite trees because its lazy.

	\item Logic Programming in Haskell,
	\\* \url{http://www.haskell.org/haskellwiki/Logic_programming_example}

	\item Haskell vs. Prolog comparison,
	\\* \url{http://stackoverflow.com/questions/1932770/haskell-vs-prolog-comparison}

	\item Haskell vs Prolog, or \yyy{"}{``}Giving Haskell a choice\yyy{"}{''}
	\\* \url{http://echochamber.me/viewtopic.php?f=11&t=35369}

	\item Killing Prolog and losing its steam,
	\\* \url{http://vanemden.wordpress.com/2010/08/21/who-killed-prolog/}
	\\* \url{http://www.kmjn.org/notes/prolog_lost_steam.html}

	\end{enumerate}
	\end{comment}

\section{Related Books}

As \progLang{Haskell} is relatively new in terms of being popular, its predecessors like \progLang{Scheme} have
explored the territory of embedding  quite profoundly \cite{friedman05reasoned}, which aims at adding a few
constructs to the language to bring together both styles of Declarative Programming and capture the essence of
\progLang{Prolog}. Moreover, \progLang{Haskell} also claims for it to be suitable for basic Logic Programming
naturally using the List Monad \cite{website:logicprogexamplehaskell}. A general out look towards implementing
\progLang{Prolog} has also been discussed by \cite{krishnamurthi2007programming} to push the ideas forward.

\begin{comment}
All the more \textit{Prologish} things exist in Haskell, as mentioned alone it is not the only one if we consider it in the ''Scheme'' \cite{friedman05reasoned} of things and so is replication to other languages \cite{krishnamurthi2007programming}.
\end{comment}

\begin{comment}
\begin{enumerate}
\item The Reasoned Schemer, Daniel P. Friedman, William E. Byrd, Oleg Kiselyov

\item Programming Languages: Application and Interpretation, Shriram Krishnamurthi,
\\*  Chapters 33-34 of PLAI discuss Prolog and implementing Prolog

\end{enumerate}
\end{comment}

\section{Related Papers}

There is quite some literature that can be found and which consist of embedding detailed parts of Prolog features
like basic constructs, search strategies and data types. One of the major works is covered by the subsection below
consisting of a series of papers from Mike Spivey and Silvija Seres aimed at bring Haskell and Prolog closer to each
other. The next subsection covers the literature based on the above with improvements and further additions.

\begin{description}

\item[$\bullet$] Papers from Mike Spivey and Silvija Seres


  The work presented in the series
  \cite{spivey1999embedding,seres1999algebra,seres2001higher,spivey1999algebra,seres2001algebra} attempts to
  encapsulate various aspects of an embedding of \progLang{Prolog} in \progLang{Haskell}.
  Being the very first documented formal attempt, the work is influenced by similar embeddings of \progLang{Prolog}
  in other languages like \progLang{Scheme} and \progLang{Lisp}.
  Although the host language has distinct characteristics such as lazy evaluation and strong type system the
  proposed scheme tends to be general as the aim here is to achieve \progLang{Prolog} like working not a multi
  paradigm declarative language.
  \progLang{Prolog} predicates are translated to \progLang{Haskell} functions which produce a stream of results
  lazily depicting depth first search with support for different strategies and practical operators such as
  \textit{cut} and \textit{fail} with higher order functions.
  The papers provide a minimalistic extension to \progLang{Haskell} with only four new constructs.
  Though no implementation exists, the synthesis and transformation techniques for functional programs have been
  \textit{logicalised} and applied to \progLang{Prolog} programs.
  Another related work \cite{spivey2000functional} looks through conventional data types so as to adapt to the
  problems at hand so as to accommodate and jump between search strategies.


\item[$\bullet$] Other works related or based on the above

%\par This section takes a look at the improvements at the attempts mostly based on the work from the previous section. Some work is done by the one of the authors above while the other prominent others in the same field.

  Continuing from above, \cite{claessen2000typed} taps into the advantages of the host language to embed a typed
  functional logic programming language.
  This results in typed logical predicates and a backtracking monad with support for various data types and search
  strategies.
  Though not very efficient nor practical the method aims at a more elegant translation of programs from one
  language to the other.
  While other papers \cite{erwig2004escape} attempt at exercising \progLang{Haskell} features without adding
  anything new rather doing something new with what is available.
  Specifically speaking, using \progLang{Haskell} type classes to express general structure of a problem while the
  solutions are instances.
  \cite{hinze1998prological} replicates \progLang{Prolog}'s control operations in \progLang{Haskell} suggesting the
  use of the \progLang{Haskell} \textit{State Monad} to capture and maintain a global state.
  The main contributions are a Backtracking Monad Transformer that can enrich any monad with backtracking abilities
  and a monadic encapsulation to turn a \progLang{Prolog} predicate into a \progLang{Haskell} function.


\end{description}


\section{Related Libraries in Haskell}
\begin{description}
\item[$\bullet$]Prolog Libraries

To replicate Prolog like capabilities Haskell seems to be already in the race with a host of related libraries. First we begin with the libraries about Prolog itself, a few exist \cite{nanoprolog-lib} being a preliminary or \yyy{"}{``}mini Prolog\yyy{"}{''} as such with not much in it to be able to be uselul, \cite{hswip-lib} is all powerful but is an Foreign Function Interface so it is \yyy{"}{``}Prolog in Haskell\yyy{"}{''} but we need Prolog for it, \cite{prolog-lib} which is the only implementation that comes the closest to something like an actual practical Prolog. But all they give is a small interpreter, none or a few practical features, incomplete support for lists, minor or no monadic support and an REPL without the ability to \yyy{"}{``}write a Prolog Program File\yyy{"}{''}.

\begin{comment}
\begin{enumerate}
	\item Nano Prolog
	\item Prolog
	\item cspm-To-Prolog
	\item prolog-graph and prolog-graph-lib
	\item hswip,
	\\* \url{https://groups.google.com/forum/#!topic/haskell-cafe/3vmCuw7NlWE}
\end{enumerate}
\end{comment}

\item[$\bullet$]Logic Libraries

The next category is about the logical aspects of Prolog, again a handful of libraries do exist and provide a part
of the functionality which is related propositional logic and backtracking. \cite{logict-lib} is a
continuation-based, backtracking, logic programming monad which sort of depicts Prolog's backtracking
behaviour. Prolog is heavily based on formal logic, \cite{proplogic-lib} provides a powerful system for
Propositional Logic. Others include small hybrid languages \cite{cflp-lib} and Parallelising Logic Programming
and Tree Exploration \cite{logic-grows-on-trees-lib}.

\begin{comment}
\begin{enumerate}
	\item logict,
	\\* \url{http://okmij.org/ftp/Computation/monads.html}
	\item logic-classes this is very unstable and does not install a lot of dependency issues and then reinstalls cause broken packages etc etc
	\item proplogic powerful system for propositional logic(seems very complicated I do not know whether it is related to Prolog in any way)
	\item cflp Concatenative Functional Logic Programming
	\item logic grows on trees == Parallelised Logic Programming / Parallel Tree Exploration
\end{enumerate}
\end{comment}

\item[$\bullet$]Unification Libraries

The more specific the feature the lesser the support in Haskell. Moving on to the other distinct feature of Prolog is
Unification, two libraries exist \cite{unification-fd-lib}, \cite{cmu-lib} that unify two Prolog Terms and return the resulting
substitution.

\begin{comment}
\begin{enumerate}
	\item unification-fd
	\item cmu
\end{enumerate}
\end{comment}

\item[$\bullet$]Backtracking

Another important aspect of \progLang{Prolog} is backtracking. To simulate it in \progLang{Haskell}, the libraries \cite{stream-monad-lib, logicst-lib} use monads. Moreover, there is a package for the \progLang{Egison} programming language \cite{egison-lib} which supports non-linear pattern-matching with backtracking.

\begin{comment}

\begin{enumerate}
	\item Egison \cite{egison-lib}
	\item stream-monad \cite{stream-monad-lib}
	\item logicst \cite{logicst-lib}
\end{enumerate}

\end{comment}

\end{description}

\begin{comment}
\section{Possibly Related Content}
\begin{enumerate}

\item Unifying Theories of Programming, C.A.R. Hoare,
\\* \url{http://www.unifyingtheories.org/}

\item Unifying Theories of Programming with Monads, Jeremy Gibbons,
\\* \url{http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/utp-monads.pdf}

\end{enumerate}
\end{comment}

\begin{comment}
\begin{description}
\item[$\bullet$]Concatenative Programming Libraries
\begin{enumerate}
	\item peg \cite{peg-lib}
\end{enumerate}

\item[$\bullet$]Constraint Programming and Constraint Handling Rules
\begin{enumerate}
	\item monadiccp \cite{monadiccp-lib}
	\item monadicccp-gecode \cite{monadiccp-gecode-lib}
	\item csp \cite{csp-lib}
	\item liquid fix point \cite{liquid-fix-point-lib}
\end{enumerate}
\end{description}
\end{comment}


\section{\textbf{From chap 7}}

Embedding a language into another language has been explored with a variety of languages. Attempts have been made to build Domain Specific Languages from the host languages \cite{hudak1996building}, Foriegn Function Interfaces \cite{barzilay2004foreign}

Creating a programming language from scratch is a tedious task requiring ample amount of programming, not to mention the effort required in
designing. A typical procedure would consist of formulating characteristics and properties based on the following points,

\begin{enumerate}
\item Syntax
\item Semamtics
\item Standard Library
\item Runtime Sytsem
\item Parsers
\item Code Generators
\item Interpreters
\item Debuggers
\end{enumerate}

A lot of the above can be skipped or taken from the base language if an embedding approach is chosen.
For an embedded domain specific language the functionality is translated and written as an add on.
The result can be thought of as a library.
But the difference between an ordinary library and an eDSl is the feature set provided and the degree of embedding
\cite{website:eDSLhaskellwiki}.
For example, reading a file and parsing its contents to perform certain operations to return \textit{string}
results is a shallow form of embedding as the generation of code, results is not native nor are the functions
processing them dealing with embedded data types as such.
On the other hand, building data structures in the base language which represent the target language expression
would be called a deep embedding approach.

The snippet of \progLang{Haskell} code below describes \progLang{Prolog} entities,

\begin{minted}[linenos]{haskell}
data Term = Struct Atom [Term]
          | Var VariableName
          | Wildcard
          | PString   !String
          | PInteger  !Integer
          | PFloat    !Double
          | Flat [FlatItem]
          | Cut Int
      deriving (Eq, Data, Typeable)
\end{minted}

The above can be described as concrete syntax for the \yyy{"}{``}new\yyy{"}{''} language and can be used to write a program.


As discussed in the

\section{Theory}
\begin{enumerate}
%------------------------------------------------------------------------------------------------------------------------------------
\item Papers
\begin{enumerate}
\item Embedding an interpreted language using higher-order functions, \cite{ramsey2003embedding}
\item Building domain-specific embedded languages, \cite{hudak1996building}
\item Embedded interpreters, \cite{benton2005embedded}
\item Cayenne -- a Language With Dependent Types, \cite{Augustsson98cayenne--}
\item Foreign interface for PLT Scheme, \cite{barzilay2004foreign}
\item Dot-Scheme: A PLT Scheme FFI for the .NET framework, \cite{pinto2003dot}
\item Application-specific foreign-interface generation, \cite{reppy2006application}
\item Embedding S in other languages and environments, \cite{lang2001embedding}
\end{enumerate}
%------------------------------------------------------------------------------------------------------------------------------------
\item Books
\begin{enumerate}
\item ?????????
\end{enumerate}
%------------------------------------------------------------------------------------------------------------------------------------
\item Articles / Blogs / Discussions
\begin{enumerate}
\item Embedding one language into another, \cite{website:lambda-the-ultimate-2}
\item Application-specific foreign-interface generation, \cite{website:lambda-the-ultimate-3}
\item Linguistic Abstraction, \cite{audklangembedd}
\item LISP, Unification and Embedded Languages, \cite{ummlisp}
\end{enumerate}
%------------------------------------------------------------------------------------------------------------------------------------
\item Websites
\begin{enumerate}
\item Embedding SWI-Prolog in other applications, \cite{swipembedd}
\end{enumerate}
%------------------------------------------------------------------------------------------------------------------------------------
\end{enumerate}

\section{Implementations}
\begin{enumerate}
\item Lots of them I guess
\end{enumerate}

\section{Important People}
\begin{enumerate}
\item ????
\end{enumerate}

\section{Miscellaneous / Possibly Related Content}
\begin{enumerate}
\item ????
\end{enumerate}


\section{Chapter Recap}


\end{document}
