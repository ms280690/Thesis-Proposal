
\documentclass[thesis-solanki.tex]{subfiles}

\begin{document}


\chapter{Embedding a Programming Language into another Programming Language }\label{chap:embedding}


\section{What is this chapter about}

The art of embedding a programming language into another one has been explored a number of times in the form
of building libraries or developing Foreign Function Interfaces and so on. This area mainly aims at an environment
and setting where two or more languages can work with each other harmoniously with each one able to play a part
in solving the problem at hand. This chapter mainly reviews the content related to embedding \progLang{Prolog} in
\progLang{Haskell} but also includes information on some other implementations and embedding languages in
general.
%Embedding a programming language into another, in this we talk about embedding Prolog in Haskell.
%The following are the sources or related work that can be found,


\section{The Informal Content from Blogs, Articles and Internet Discussions}

Before moving on to the formal content such as publications, modules and libraries let's take a look at some of the
unofficially published content.
This subsection takes a look at the information, thoughts and discussions that are currently taking place from time
to time on the internet.
A lot of interesting content is generated which has often led to some formal content.

A lot has been talked about embedding languages and also the techniques and methods to do so.
It might not seem such a hot topic as such but it has always been a part of any programming language to work and
integrate their code with other programming languages.
One of the top discussions are in, Lambda the Ultimate, The Programming Languages Weblog
\cite{website:lambda-the-ultimate}\xxx{,  which} lists a number of \progLang{Prolog} implementations in a variety of
languages like \progLang{Lisp, Scheme, Scala, Java, Javascript}, \progLang{Racket} \cite{racklog} and so on.
Moreover the discussion focuses on a lot of critical points that should be considered in a translation of
\progLang{Prolog} to the host language in terms of types and modules among others.

One of the implementations discussed redirects us to one of the earliest implementations of \progLang{Prolog}
in \progLang{Haskell} for Hugs 98, called Mini \progLang{Prolog} \cite{website:mini-prolog-hugs98}.\endnote{%
  Reword.
  I believe that the list of facts that you are trying to combine is:
  \begin{compactitem}
  \item
    One of the implementations discussed on ``Lambda The Ultimate''
    leads us something.
  \item
    \texttt{Mini Prolog} (\cite{website:mini-prolog-hugs98}) is 
    one of the earliest implementations of \progLang{Prolog} in \progLang{Haskell}.
  \item
    \texttt{Mini Prolog} works with
    \progLang{Hugs 98}, an early dialect of \progLang{Haskell}.
  \end{compactitem}
}
Although this implementation takes as reference the working of the \progLang{ Prolog} Engine\endnote{%
  What is the \progLang{Prolog} Engine?
}
and other details, it
still is an unpublished implementation
with almost no documentation, support  or ongoing development.
Moreover, it comes with an option of three engines to play
with{\large,} but still lacks complete list support\endnote{%
  \david{What is list support?  What is complete list support?  You have not
  defined either of these terms.}\newline
  \mehul{I forgot}.
}
and a lot of 
practical features that \progLang{Prolog} has.
This seems to be a common problem with the other
implementation that exists, \cite{website:takashi-workplace}.

Adding fuel to fire, is the question on \progLang{Prolog}'s existence and survival
\cite{website:prolog-killer,website:prolog-steam,website:prolog-death,somogyi1995logic} since its use in industry
is far scarcer\endnote{%
  ``far scarcer''?
}
than the leading languages of other paradigms.
The purely declarative nature lacks basic requirements such as support for modules.\endnote{%
  Do you mean that basic \progLang{Prolog} implementations lack modules;
  or that \progLang{Prolog} lacks modules because it is purely
  declarative; or \dots?
}
The other issue is the ongoing comparison between the siblings \cite{website:haskell-choice} of the same family, the
family of Declarative Languages.\endnote{%
  \david{What does this sentence mean?
  Are you suggesting that one of \progLang{Prolog}'s problems is that it is
  competing with \progLang{Haskell}?
  }\par
  \mehul{
  Well \progLang{Haskell} has a lot of advantages over \progLang{Prolog} despite being from the same paradigm
  \newline
  So a choice has to be made for a declarative language why not \progLang{Haskell} ?}
}
Not to forget \progLang{Haskell} also has some tricks \cite{website:logic-programming-haskell} up its sleeve which
enables encoding of search problems.\endnote{%
  \david{I have lost track of the general argument here.
  What is the unofficially published content saying about \progLang{Prolog} here?}
  
  \mehul{Attempting to do AI like search stuff in \progLang{Haskell}}
}

\section{Related Books}
\textcolor{blue}{Perhaps the section title should be ``Books related to embedding Programming Languges''.}

As \progLang{Haskell} is relatively new in terms of being popular, its predecessors like\endnote{%
  Consider using ``such as'' in place of ``like''.
}\elabel{such-as-like}
\progLang{Scheme} have
explored the territory of embedding  quite profoundly \cite{friedman05reasoned}, which aims at adding a few
constructs to the language to bring together both styles of Declarative Programming and capture the essence of
\progLang{Prolog}.
Moreover, \progLang{Haskell} also claims for it to be suitable for basic Logic Programming naturally using the List
Monad \cite{website:logicprogexamplehaskell}.
A general out look towards implementing \progLang{Prolog} has also been discussed by
\cite{krishnamurthi2007programming} to push the ideas forward.\endnote{%
  This \P{} needs a lot of work.
  I do not understand what you say the references say.
}

\section{Related Papers}
\textcolor{blue}{Perhaps the section title should be ``Papers related to embedding Programming Languges''.}

Abundant literature 
can be found \yyy{which consist of}{on} embedding detailed parts of Prolog features
like\eref{such-as-like} basic constructs, search strategies and data types.
One of the major works is covered by the subsection below consisting of a series of papers from Mike Spivey and
Silvija Seres aimed at bring \progLang{Haskell} and \progLang{Prolog} closer to each other.
The next subsection covers the literature based on the above\endnote{%
  I am not sure what ``the above'' refers to here: \cite{spivey1999embedding}?.
}
with improvements and further additions.


\subsection{Papers from Mike Spivey and Silvija Seres}


The work presented in the series
\cite{spivey1999embedding,seres1999algebra,seres2001higher,spivey1999algebra,seres2001algebra} attempts to
encapsulate various aspects of an embedding of \progLang{Prolog} in \progLang{Haskell}.
Being the very first documented formal attempt, the work is influenced by similar embeddings of \progLang{Prolog}
in other languages like \progLang{Scheme} and \progLang{Lisp}.
Although the host language has distinct characteristics such as lazy evaluation and strong type system the proposed
scheme tends to be general as the aim here is to achieve
\progLang{Prolog} like\eref{language-like} working not a multi paradigm 
declarative language.
\progLang{Prolog} predicates are translated to \progLang{Haskell} functions which produce a stream of results
lazily depicting depth first search with support for different strategies and practical operators such as
\textit{cut} and \textit{fail} with higher order functions.
The papers provide a minimalistic extension to \progLang{Haskell} with only four new constructs.
Though no implementation exists, the synthesis and transformation techniques for functional programs have been
\textit{logicalised} and applied to \progLang{Prolog} programs.
Another related work \cite{spivey2000functional} looks through conventional data types so as to adapt to the
problems at hand\endnote{% 
  What are ``the problems at hand''?
} and accommodate and jump between search strategies.


\subsection{Other works related or based on the above}

%\par This section takes a look at the improvements at the attempts mostly based on the work from the previous section. Some work is done by the one of the authors above while the other prominent others in the same field.

Continuing from above, \cite{claessen2000typed} taps into the advantages of the host language to embed a typed
functional logic programming language.
This results in typed logical predicates and a backtracking monad with support for various data types and search
strategies.
Though not very efficient nor practical the method aims at a more elegant translation of programs from one language
to the other.
While other papers \cite{erwig2004escape} attempt at exercising \progLang{Haskell} features without adding
anything new rather than doing something new with what is available.\endnote{%
    This is a sentence fragment.
  }
Specifically speaking, using \progLang{Haskell} type classes to express general structure of a problem while the
solutions are instances.\endnote{%
    I do not understant the preceding sentence.
  }
\cite{hinze1998prological} replicates \progLang{Prolog}'s control operations in \progLang{Haskell} suggesting the
use of the \progLang{Haskell} \textit{State Monad} to capture and maintain a global state.
The main contributions are a Backtracking Monad Transformer that can enrich any monad with backtracking abilities
and a monadic encapsulation to turn a \progLang{Prolog} predicate into a \progLang{Haskell} function.



\section{Related Libraries in Haskell}
%\begin{description}
%\item[$\bullet$]\endnote{%
%%   See the preceding comments about using \texttt{itemize} rather than \texttt{description}.
%%   Maybe these should be subsections.
%% }
\subsection{Prolog Libraries}

To replicate \progLang{Prolog} like\eref{language-like}
capabilities Haskell seems to be already in the race\endnote{%
  Yet another metaphor whose meaning I do not understand in context.
}
with a host of related libraries.
First we begin with the libraries about Prolog itself, a few exist \cite{nanoprolog-lib} being a preliminary or
``mini Prolog'' as such with not much in it to be able to be uselul, \cite{hswip-lib} is all powerful but is an
foreign function interface so it is ``\progLang{Prolog} in \progLang{Haskell}'' but we need Prolog for it,
\cite{prolog-lib} which is the only implementation that comes the closest to something like an actual practical
Prolog.
But all they give is a small interpreter, none or a few practical features, incomplete support for lists, minor or
no monadic support and an REPL without the ability to ``write a Prolog Program File''.

%\item[$\bullet$]Logic Libraries
\subsection{Logic Libraries}

  The next category is about the logical aspects of Prolog; again a handful of libraries do exist and provide a
  part of the functionality which are related\endnote{%
    There seem to be words missing here.
}
  to propositional logic and backtracking.
  \cite{logict-lib} is a continuation-based, backtracking, logic programming monad which attempts at replicating\endnote{%
    Be more precise than ``sort of depicts''.
}
  \progLang{Prolog}'s
  backtracking behaviour.
  Prolog is heavily based on formal logic.
  \cite{proplogic-lib} provides a powerful system for Propositional Logic.
  Other libraries\endnote{%
    Other whats?
}
  include small hybrid languages \cite{cflp-lib} and
  \textcolor{blue}{``Parallelising Logic Programming and Tree Exploration''}\endnote{%
    Mark this text up somehow: for intance surround with quotation marks if it is the title of a paper, put in
    italics if it is a book, and so on.
}
  \cite{logic-grows-on-trees-lib}.


%\item[$\bullet$]Unification Libraries
\subsection{Unification Libraries}

The more specific the feature{\Large,} the lesser the support in \progLang{Haskell}.
Moving on to the other distinct feature of \progLang{Prolog} is unification.\endnote{%
  ``Moving on to the other distinct feature of Prolog is Unification.''?  Say it aloud.
}
There are two libraries that exist \cite{unification-fd-lib},
\cite{cmu-lib} that unify two Prolog Terms and return the resulting substitution.\endnote{%
  Do you want to make the point here that \cite{unification-fd-lib} is more general than just \progLang{Prolog}? 

\mehul{I do not know since we are just listing stuff out.}
}


%\item[$\bullet$]Backtracking
\subsection{Backtracking}

Another important aspect of \progLang{Prolog} is backtracking.
To simulate it in \progLang{Haskell}, the libraries \cite{stream-monad-lib, logicst-lib} use monads.
Moreover, there is a package for the \progLang{Egison} programming language \cite{egison-lib} which supports
non-linear pattern-matching with backtracking.


%% \end{description}



\section{\textbf{From chap 7}}

\textcolor{blue}{\itshape This material needs to be integrated, or minimally, the section title changed.}

Embedding a language into another language has been explored with a variety of languages.\endnote{%
  How do these two sentences relate?
}
Attempts have been made to build Domain Specific Languages from the host languages \cite{hudak1996building},
Foriegn Function Interfaces \cite{barzilay2004foreign}

Creating a programming language from scratch is a tedious task requiring ample\endnote{%
  Ample doesn't fit well here.
}
amount of programming, not to
mention the effort required in designing.
A typical procedure would consist of formulating characteristics and properties based on the following points,

\begin{enumerate}
\item Syntax
\item Semamtics
\item Standard Library
\item Runtime Sytsem
\item Parsers
\item Code Generators
\item Interpreters
\item Debuggers
\end{enumerate}

A lot of the above can be skipped or taken from the base language if an embedding approach is chosen.\endnote{%
  This \P{} is good.
}
For an embedded domain specific language the functionality is translated and written as an add on.
The result can be thought of as a library.
But the difference between an ordinary library and an eDSl is the feature set provided and the degree of embedding
\cite{website:eDSLhaskellwiki}.
For example, reading a file and parsing its contents to perform certain operations to return \textit{string}
results is a shallow form of embedding as the generation of code, results is not native nor are the functions
processing them dealing with embedded data types as such.
On the other hand, building data structures in the base language which represent the target language expression
would be called a deep embedding approach.

The snippet of \progLang{Haskell} code below describes \progLang{Prolog} entities,

\begin{minted}[linenos]{haskell}
data Term = Struct Atom [Term]
          | Var VariableName
          | Wildcard
          | PString   !String
          | PInteger  !Integer
          | PFloat    !Double
          | Flat [FlatItem]
          | Cut Int
      deriving (Eq, Data, Typeable)
\end{minted}

The above can be described as concrete syntax for the \yyy{"}{``}new\yyy{"}{''} language and can be used to write a program.


As discussed in the\marginpar{{\color{red}\large *}}\endnote{%
  Something strange has happened here!.
}

\section{Theory}
\textcolor{blue}{Is this still from Chapter 7?}
\begin{enumerate}
%------------------------------------------------------------------------------------------------------------------------------------
\item Papers
\begin{enumerate}
\item Embedding an interpreted language using higher-order functions, \cite{ramsey2003embedding}
\item Building domain-specific embedded languages, \cite{hudak1996building}
\item Embedded interpreters, \cite{benton2005embedded}
\item Cayenne -- a Language With Dependent Types, \cite{Augustsson98cayenne--}
\item Foreign interface for PLT Scheme, \cite{barzilay2004foreign}
\item Dot-Scheme: A PLT Scheme FFI for the .NET framework, \cite{pinto2003dot}
\item Application-specific foreign-interface generation, \cite{reppy2006application}
\item Embedding S in other languages and environments, \cite{lang2001embedding}
\end{enumerate}
%------------------------------------------------------------------------------------------------------------------------------------
\item Books
\begin{enumerate}
\item ?????????
\end{enumerate}
%------------------------------------------------------------------------------------------------------------------------------------
\item Articles / Blogs / Discussions
\begin{enumerate}
\item Embedding one language into another, \cite{website:lambda-the-ultimate-2}
\item Application-specific foreign-interface generation, \cite{website:lambda-the-ultimate-3}
\item Linguistic Abstraction, \cite{audklangembedd}
\item LISP, Unification and Embedded Languages, \cite{ummlisp}
\end{enumerate}
%------------------------------------------------------------------------------------------------------------------------------------
\item Websites
\begin{enumerate}
\item Embedding SWI-Prolog in other applications, \cite{swipembedd}
\end{enumerate}
%------------------------------------------------------------------------------------------------------------------------------------
\end{enumerate}

\section{Implementations}
\begin{enumerate}
\item Lots of them I guess
\end{enumerate}

\section{Important People}
\begin{enumerate}
\item ????
\end{enumerate}

\section{Miscellaneous / Possibly Related Content}
\begin{enumerate}
\item ????
\end{enumerate}

\section{Chapter Recapitulation}


\end{document}
