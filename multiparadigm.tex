\documentclass[thesis-solanki.tex]{subfiles}


\begin{document}

\chapter{Multi Paradigm Languages (Functional Logic Languages)}\label{chap:multiparadigm}


\section{What is this chapter about}

-----------------------------------------------------------------------------


Over the years another approach has branched off from embedding languages, to merge and/or integrate programming
languages from different paradigms.
Let us take an example of the \progLang{Scala} Programming Language \cite{website:scala}, a hybrid
Object-Functional Programming Language which takes a leaf from each of the two books.
In this thesis, the languages in question are \progLang{Haskell} and \progLang{Prolog}.
This section takes a look at the literature on Multi Paradigm Languages, mainly Functional Logic Programming
Languages that combine two of the most widespread Declarative Programming Styles.

A peak into language classification reveals that it is not always a straight forward task to segregate languages
according to their features and/or characteristics.
Turns out that there are a number of notions which play a role in deciding where the language belongs.
Many a times a language ends up being a part of almost all paradigms due extensive libraries.
Simply speaking, a multi-paradigm programming language is a programming language that supports more than one
programming paradigm \cite{Krishnamurthi:2008:TPL:1480828.1480846}, more over as Timothy Budd puts it
\cite{website:wikimultiparadigm} \yyy{"}{``}The idea of a multi paradigm language is to provide a framework in
which programmers can work in a variety of styles, freely intermixing constructs from different
paradigms.\yyy{"}{''}


\section{The Informal Content from Blogs, Articles and Internet Discussions}
%\begin{description}
  
\subsection{Multi Paradigm Languages}

  A lot has been talked and discussed on coming to clear grounds about the classification of programming languages.
  If the conventional ideology is considered then the scope of each language is pretty much infinite as small
  extension modules replicate different feature sets which are not naturally native to the language itself.
  The definitions of multi paradigm languages across the web
  \cite{website:wikimultiparadigm,website:mdn,website:blogc2} converge to roughly the same thing that of providing
  a framework to work with different styles with a list of languages \cite{website:wikimpllist,website:dmoz} that
  ticks the boxes.
  Generally speaking, it does not feel all that hot or popular in programming circles; one reason could be that it
  is a very broad topic and specifying details can clear the fog.

\subsection{Functional Logic Programming Languages}

  Continuing from the previous section, narrowing down the search by considering only multi paradigm declarative
  languages namely, Functional Logical programming languages.
  By doing so a large amount of information pops up, from articles that give brief description and mentions
  \cite{website:wikiflpl, website:wikiflpllist} to the implementing techniques \cite{website:imlpementingflpl}
  which give a brief overview of the aim and also the backdrop of publications.

  The jackpot however is the fact that there is a dedicated website \cite{website:funclogprog} for the history,
  research and development, existing languages, the literature, the contacts and everything else that one can think
  of for functional logic languages.
  As a matter of fact the holy grail of information is maintained by two of the most important people in the field
  Michael Hanus \cite{website:mhanus} and Sergio Antoy \cite{website:santoy}.


%\end{description}


\section{Literature and Publications}
%\begin{description}
\subsection{Multi Paradigm Languages}
  Possibly one of the most important works towards bringing programming styles together is the book by C.A.R.
  Hoare \cite{hoare1998unifying} which points out that among the large number of programming paradigms and/or
  theories the unification theory serves as a complementary rather than a replacement to relate the universe.
  As as always since we are talking about \progLang{Haskell} we have to\endnote{%
  Use ``must'' in place of ``have to'' where you can.
}\elabel{must-have-to} include monads and unifying theories using
  monads \cite{gibbons2013unifying}.
 

\subsection{Functional Logic Programming Languages}

A recent survey \cite{hanus2007multi} throws light on these hybrid languages. 

One of the most prominent multi paradigm languages in \progLang{Haskell} is \progLang{Curry}
\cite{antoy2010functional}.
Th syntax is borrowed from the parent language and so are a lot of the features.
Taking a recap, a functional programming language works on the notion of mathematical functions while a logic
programming language is based on predicate logic.
The strong points of \progLang{Curry} are that the features or basis of the language are general and are visible in
a number of languages like \cite{website:toy}.
The language can play with problems from both worlds.
In a problem where there are no unknowns and/or variables the language behaves like a functional language which is
pattern matching the rules and execute the respective bodies.
In the case of missing information, it behaves like \progLang{Prolog}; a sub-expression \textit{e} is evaluated on
the conditions that it should satisfy which constraint the possible values of \textit{e}.
This brings us to the first important feature of functional logic languages \textit{narrowing}.
The expressions contain \textit{free variables}; simply speaking incomplete information that needs to be
\textit{unified} to a value depending on the constraints of the problem.
The language introduces only a few new constructs to support non determinism and choice.
Firstly, \textit{narrowing} ($\mathtt{=:=}$), which deals with the expressions and unknown values and binds them
with appropriate values.
The next one is the \textit{choice} operator ($\mathtt{?}$) for non-deterministic operations.
Lastly, for unifying variables and values under some conditions, ($\mathtt{\&}$) operator has been provided to add
constraints to the equation.
Putting it all together, it gives us the feel of a logic language for something that looks very much like
\progLang{Haskell}.
Unification is like two way pattern matching and with a similar analogy \progLang{Curry} is a \progLang{Haskell}
that works both ways and hence variables can be on either sides.
Although the language can do a lot but gaps do exist such as the improvement of narrowing techniques.
 
 
%\end{description}

\section{Some Multi Paradigm Languages}

The list of multi paradigm languages is huge, but in this thesis we will mostly stick to Functional Logical programming languages. Beginning with functional hybrids, a small project language called \progLang{Virgil} \cite{website:virgil}, combining objects to work with functions and procedures. On similar lines is \progLang{Common Object Lisp System (CLOS)} \cite{website:closwiki}. This can be justified as object oriented programming has been one of the most dominant styles of programming and hence even \progLang{Haskell} has one called \progLang{O'Haskell} \cite{website:ohaskell} though it last saw a release back in 2001. Another prominent implementation is \progLang{OCaml} \cite{website:ocamlwiki,website:ocamllang} which adds object oriented capabilities with a powerful type system and module support. This is the case with most of the languages in this section hardly a few have survived as the new ones incorporated the positives of the old.  As mentioned before one of the most poplar \cite{website:langpop} and widely usage both in academia and industry is the \progLang{Scala} \cite{website:scala} programming language stands out.       


\section{Functional Logic Programming Languages}

Knowing that there is quite some amount of literature out there on these type of languages, it is fairly easy to say that there have been numerous 
attempts at specifications and/or implementations. Sadly though not many have survived leave alone being successful as a result of the competition. 
Only the ones that are easily available or have an implementation or have been cited or referred by other attempts have been included as the list is long 
and does not reflect the main intention of the document. Beginning with the ones from Australia, which seems to be a popular destination for fiddling 
with \progLang{Prolog} and merging paradigms. As of now there have been three popular ones, beginning with \progLang{Neu Prolog}, 
\cite{website:nue-prolog}, \progLang{Oz (Mozart Programming System)} \cite{website:oz-mozart} and \progLang{Mercury} \cite{website:mercury}. 
Delving deeper the languages feel more like extensions of \progLang{Prolog} rather than hybrids. Starting with \progLang{Mercury} which a boundary 
between deterministic and non-deterministic programs, similarly \progLang{Nue Prolog} has special support for functions while \progLang{Oz} gives  
concurrent constraint programming plus distributed support, with different function types for goal solving and expression rewriting.  \progLang{Escher} 
\cite{lloyd1999programming:escher} comes very close to \progLang{Haskell} with monads, higher order functions and lazy evaluation. Taking a look at 
\progLang{Prolog} variants, \progLang{Ciao} \cite{website:ciao}; a preprocessor to \progLang{Prolog} for functional syntax support, \progLang{$\lambda
$ Prolog} \cite{website:lambda-prolog} aims at modular higher order programming with abstract data types in a logical setting, \progLang{Babel} \cite{
website:babel,moreno1992logic, moreno1988babel} combines pure \progLang{Prolog} with a first order functional notation, \progLang{LIFE} \cite{
website:life} is for  Logic, Inheritance, Functions and Equations in \progLang{Prolog} syntax with currying and other features like functional languages 
and others \cite{bert1987lpg,malachi1984tablog}.

The functional language \progLang{Scheme} is a very popular choice for this sort of a thing. With a book \cite{friedman05reasoned} and an implementation to accompany \cite{website:kanren,website:minkanren} which seems to have translated into \progLang{Haskell}, 
\cite{website:haskellkanren,website:molog,website:minikanrent}. 

Finally talking about \progLang{Curry}, one of the most popular \progLang{Haskell} based multi paradigm languages with support for deterministic and non-deterministic computations. Contributing to the same there have been some predecessors \cite{website:alf,website:toy}.       


\section{\textbf{From chap 9}}

Unifying / Marrying / Merging / Combining Programming Paradigms / Theories
\section{Theory}
\begin{description}

\item[$\bullet$] Papers
\begin{enumerate}
\item Unifying Theories of Programming with Monads, \cite{gibbons2013unifying}

\item Symposium on Unifying Theories of Programming, 2006, \cite{DBLP:conf/utp/2006}.

\item Symposium on Unifying Theories of Programming, 2008, \cite{DBLP:conf/utp/2008}.

\item Symposium on Unifying Theories of Programming, 2010, \cite{DBLP:conf/utp/2010}.

\item Symposium on Unifying Theories of Programming, 2012, \cite{DBLP:conf/utp/2012}.

\end{enumerate}

\item[$\bullet$] Books
\begin{enumerate}
\item Unifying Theories of Programming, \cite{hoare1998unifying}
\end{enumerate}

\item[$\bullet$] Articles / Blogs / Discussions
\begin{enumerate}
\item ???
\end{enumerate}

\item[$\bullet$] Websites
\begin{enumerate}
\item ???
\end{enumerate}

\end{description}


\section{Implementations}
\begin{enumerate}
\item Scala
\item Virgil
\item CLOS, Common Lisp Object System
\item Visual Prolog
\item ????
\end{enumerate}

\section{Miscellaneous / Possibly Related Content}
\begin{enumerate}
\item ???
\end{enumerate}



\section{Chapter Recapitulation}

\end{document}
