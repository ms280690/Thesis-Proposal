\documentclass[thesis-solanki.tex]{subfiles}


\ifMain
\externaldocument{thesis-solanki}
\fi
\begin{document}

\chapter{Multi Paradigm Languages (Functional Logic Languages)}\label{chap:multiparadigm}


\section{About this chapter}

This chapter describes the approach for integrating properties of multiple languages from different programming paradigms, especially, 
functional logic programming languages.  

\section{Section title needed}
Over the years another approach has branched off from embedding languages, to merge and/or integrate programming
languages from different paradigms.
Let us take an example of the \progLang{Scala} programming language \cite{website:scala}, a hybrid
object-functional programming language which takes features from each of the two paradigms.
In this thesis, the languages in question are \progLang{Haskell} and \progLang{Prolog}.
This section takes a look at the literature on multi paradigm languages, mainly functional logic programming
languages that combine two of the most widespread declarative programming styles.

A peak into language classification reveals that it is not always a straight forward task to segregate languages
according to their features and characteristics.
It turns out that there are a number of notions which play a role in deciding where the language belongs.
Often a language ends up being a part of almost all paradigms due to extensive libraries.
Simply speaking, a multi paradigm programming language is a programming language that supports more than one
programming paradigm \cite{Krishnamurthi:2008:TPL:1480828.1480846}.Moreover, as Timothy Budd puts it
\cite{website:wikimultiparadigm} ``The idea of a multi paradigm language is to provide a framework in which
programmers can work in a variety of styles, freely intermixing constructs from different paradigms.''


\section{The Informal Content from Blogs, Articles and Internet Discussions}
%\begin{description}
  
\subsection{Multi Paradigm Languages}

A lot has been worked upon before coming to clear grounds about the classification of programming languages.
One approach is to consider that the scope of each language is pretty much infinite as small extension modules that
replicate different feature sets which are not naturally native to the language itself can be implemented on top of
the base language.
The descriptions of multi paradigm languages across the web
\cite{website:wikimultiparadigm,website:mdn,website:blogc2} converge to roughly of a framework providing tools to work with different 
styles of programming \cite{website:wikimpllist,website:dmoz}.
Generally speaking, this
is not very popular in programming circles; one reason could be that it
is a very broad topic and specifying details can be helpful.\endnote{%
  \mehul{changed}.\newline
  \david{The English now reads well, but I am not certain what you are trying to say.
  I take ``\textit{Generally speaking, this is not very popular in programming circles;}'' to mean that programmers
  are not very fond of multi-paradigm languages.  Is that what you meant?
  Does ``\textit{\dots; one reason could be that it is a very broad topic and specifying details can be helpful.}''
  mean \textsl{one reason that multi-paradigm languages are not popular with programmers could be that\dots}; no, I
  do not see how to complete that thought.}
}

\subsection{Functional Logic Programming Languages}

Continuing from the previous section, we narrow down the scope by considering only multi paradigm declarative
languages, i.e. functional logical programming languages.
By doing so a large amount of information pops up, from articles that give brief description and mentions
\cite{website:wikiflpl, website:wikiflpllist} to the ones that provide implementation techniques\endnote{%
  Are the previous two fixes correct?
  If so, remove this endnote.
}
\cite{website:imlpementingflpl}, which also give an overview of the aim and also the list of publications.\endnote{%
  Have I understood it?
  If not, revert the change and try again.
}

\begin{comment}

The important piece however is the fact that there is a dedicated website \cite{website:funclogprog} for the history,
research and development, existing languages, the literature, the contacts and everything else that one can think
of for functional logic languages.
\end{comment}
An important resource for this topic can be found in \cite{website:funclogprog} which is maintained by Michael Hanus \cite{website:mhanus} 
and Sergio Antoy \cite{website:santoy} who have developed \progLang{Curry} \cite{hanus1995curry}.

\begin{comment}
As a matter of fact the holy grail of information is maintained by two of the most important people in the field
Michael Hanus \cite{website:mhanus} and Sergio Antoy \cite{website:santoy}.
\end{comment}


%\end{description}


\section{Literature and Publications}
%\begin{description}
\subsection{Multi Paradigm Languages}
Possibly one of the most important works towards bringing programming styles together is the book by C.A.R.
Hoare \cite{hoare1998unifying} which points out that among the large number of programming paradigms and/or
theories the unification theory serves as a complementary rather than a replacement to relate the universe.
As as always since we are talking about \progLang{Haskell} we must include monads and unifying theories using
monads \cite{gibbons2013unifying}.
 

\subsection{Functional Logic Programming Languages}

A recent survey \cite{hanus2007multi} throws light on these hybrid languages. 

One of the most prominent multi paradigm languages in \progLang{Haskell} is \progLang{Curry}
\cite{antoy2010functional}.
The syntax is borrowed from the parent language and so are a lot of the features.
Recapitulating, a functional programming language works on the notion of mathematical functions while a logic
programming language is based on predicate logic.
The strong points of \progLang{Curry} are that the features or basis of the language are general and are visible in
a number of languages like \cite{website:toy}.
The language can play with problems from both worlds.
In a problem where there are no unknowns and/or variables the language behaves like a functional language which is
pattern matching the rules and execute the respective bodies.
In the case of missing information, it behaves like \progLang{Prolog}; a sub-expression \textit{e} is evaluated on
the conditions that it should satisfy which constraint the possible values of \textit{e}.
This brings us to the first important feature of functional logic languages \textit{narrowing}.
The expressions contain \textit{free variables}; simply speaking incomplete information that needs to be
\textit{unified} to a value depending on the constraints of the problem.
The language introduces only a few new constructs to support non determinism and choice.
Firstly, \textit{narrowing} ($\mathtt{=:=}$), which deals with the expressions and unknown values and binds them
with appropriate values.
The next one is the \textit{choice} operator ($\mathtt{?}$) for non-deterministic operations.
Lastly, for unifying variables and values under some conditions, ($\mathtt{\&}$) operator has been provided to add
constraints to the equation.
Putting it all together, it gives us the feel of a logic language for something that looks very much like
\progLang{Haskell}.
Unification is like two way pattern matching and with a similar analogy \progLang{Curry} is a \progLang{Haskell}
that works both ways and hence variables can be on either sides.
Although the language can do a lot; gaps do exist, such as the improvement of narrowing techniques.
 
 
%\end{description}

\section{Some Multi Paradigm Languages}

The list of multi paradigm languages is huge, but in this thesis we will mostly stick to functional logical
programming languages. Beginning with functional hybrids, a small project language called \progLang{Virgil}
\cite{website:virgil}, combines objects to work with functions and procedures.
On similar lines is \progLang{Common Object Lisp System (CLOS)} \cite{website:closwiki}.
Combining objects with functions is important as object-oriented programming has become one of the most common styles of programming. Hence 
even \progLang{Haskell} has a combined language \enparen{called \progLang{O'Haskell}, \cite{website:ohaskell}}, though it last saw a 
release back in 2001.
as object oriented programming has been a dominant styles of programming. Even \progLang{Haskell} has one called \progLang{O'Haskell}
\cite{website:ohaskell},
though it last saw a release back in 2001.
Another prominent implementation is \progLang{OCaml}
\cite{website:ocamlwiki,website:ocamllang},
which adds object oriented capabilities to a powerful type system and module support.
This is the case with most of the languages of the \yyy{paradigm,most}{paradigm{\Large.} Most} of them were developed as a proof of concept and are replaced by 
new ones based on different approaches to developing a multi paradigm language.\endnote{%
  Fix the comma and remove this endnote.
}
As mentioned before, one of the most poplar \cite{website:langpop} and widely used both in academia and industry is
the \progLang{Scala} \cite{website:scala} programming language.


\section{Functional Logic Programming Languages}

Knowing the amount of literature  on these type of languages, it is fairly easy to say that there have been numerous 
attempts at specifications and implementations.
Sadly though, not many have survived, let alone been successful.
Only the ones that are easily available
\begin{inparaenum}[(a)]
\item
  are easily available or
\item
  have an implementation or
\item
  have been cited or referred by other attempts
\end{inparaenum}
have been included below, as the list is long and not the main focus of the thesis.
We begin with variants of \progLang{Prolog}.
As of now there have been three popular ones, beginning with \progLang{Nue Prolog}, \cite{website:nue-prolog},
\progLang{Oz (Mozart Programming System)} \cite{website:oz-mozart} and \progLang{Mercury} \cite{website:mercury}.
These languages feel more like extensions of \progLang{Prolog} rather than hybrids.
To start with \progLang{Mercury} represents a boundary between deterministic and non-deterministic programs.
Similarly, \progLang{Nue Prolog} has special support for functions, while \progLang{Oz} gives concurrent constraint
programming plus distributed support, with different function types for goal solving and expression rewriting.
\progLang{Escher} \cite{lloyd1999programming:escher} comes very close to \progLang{Haskell} with monads, higher
order functions and lazy evaluation.
We take a look at \progLang{Prolog} variants: \progLang{Ciao} \enparen{\cite{website:ciao}} is a preprocessor to
\progLang{Prolog} for functional syntax support; \progLang{$\lambda $ Prolog}
\enparen{\cite{website:lambda-prolog}} aims at modular higher order programming with abstract data types in a
logical setting; \progLang{Babel} \enparen{\cite{website:babel,moreno1992logic, moreno1988babel}} combines pure
\progLang{Prolog} with a first order functional notation; \progLang{LIFE} \enparen{\cite{website:life}} is for
Logic, Inheritance, Functions and Equations in \progLang{Prolog} syntax with currying and other features like
functional languages; and there are others \enparen{\cite{bert1987lpg,malachi1984tablog}}.

The functional language \progLang{Scheme} is a very popular choice for adding logic programming functionality to a functional 
language.
The book \cite{friedman05reasoned} along with the accompanying implementation \cite{website:kanren,website:minkanren} provides a similar 
approach\yyy{}{\Large,} but for \progLang{Haskell} \cite{website:haskellkanren,website:molog,website:minikanrent}.


Finally talking about \progLang{Curry}, one of the most popular \progLang{Haskell} based multi paradigm languages
with support for deterministic and non-deterministic computations. Contributing to the same there have been some
predecessors \cite{website:alf,website:toy}.        


\section{Chapter Recapitulation}
Recapitulating, this chapter surveys the approach to merging different programming paradigms to result in a hybrid programming language. Moreover, we talked about multi paradigm declarative languages along with \progLang{Prolog} and \progLang{Haskell} hybrids.  


\ifMain
\begin{scope}
  \nolinenumbers
  \enotesize
  \par
  \begin{singlespace}
  \setlength{\parskip}{12pt plus 2pt minus 1pt}
  \theendnotes
  \par
  \end{singlespace}
\end{scope}
\unbcbibliography{bibliography}
\fi

\end{document}
