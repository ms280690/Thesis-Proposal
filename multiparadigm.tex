\documentclass[thesis-solanki.tex]{subfiles}


\ifMain
\externaldocument{thesis-solanki}
\fi
\begin{document}

\chapter{Multi Paradigm Languages (Functional Logic Languages)}\label{chap:multiparadigm}


\section{What this chapter is about}

\noindent\rule{\textwidth}{0.5pt}
%-----------------------------------------------------------------------------


Over the years another approach has branched off from embedding languages, to merge and/or integrate programming
languages from different paradigms.
Let us take an example of the \progLang{Scala} programming language \cite{website:scala}, a hybrid
object-functional programming language which takes a leaf from each of the two books.\endnote{%
  Unless you are using leaf in the sense of page (as in \textit{overleaf}), ``a leaf from each of the [two] books''
  is a mixed metaphor.
}
In this thesis, the languages in question are \progLang{Haskell} and \progLang{Prolog}.
This section takes a look at the literature on multi paradigm languages, mainly functional logic programming
languages that combine two of the most widespread declarative programming styles.\endnote{%
  There are some capitals to look at here.
}\elabel{capitals}

A peak into language classification reveals that it is not always a straight forward task to segregate languages
according to their features and characteristics.
It turns out that there are a number of notions which play a role in deciding where the language
belongs. 
Often a language ends up being a part of almost all paradigms due to extensive libraries.
Simply speaking, a multi paradigm programming language is a programming language that supports more than one
programming paradigm \cite{Krishnamurthi:2008:TPL:1480828.1480846}.Moreover, as Timothy Budd puts it
\cite{website:wikimultiparadigm} ``The idea of a multi paradigm language is to provide a framework in
which programmers can work in a variety of styles, freely intermixing constructs from different
paradigms.''


\section{The Informal Content from Blogs, Articles and Internet Discussions}
%\begin{description}
  
\subsection{Multi Paradigm Languages}

  A lot has been said and discussed on\endnote{%
    ``discussed on'' does not work.
}
  coming to clear grounds about the classification of programming languages.
  If the conventional ideology\endnote{%
    What is the ``conventional ideology'' here?  As defined where?
}
  is considered then the scope of each language is pretty much infinite as small
  extension modules replicate different feature sets which are not naturally native to the language itself.
  The definitions of multi paradigm languages across the web
  \cite{website:wikimultiparadigm,website:mdn,website:blogc2} converge to roughly the same thing that of providing
  a framework to work with different styles with a list of languages \cite{website:wikimpllist,website:dmoz} that
  ticks the boxes.\endnote{%
    Yet another metaphor that doesn't spin my wheels.
}
  Generally speaking, it\endnote{%
    What is ``it'' here?
}
  does not feel all that hot or popular in programming circles; one reason could be that it\endnote{%
    What is ``it'' here?  Is this the same ``it'' as above?
}
  is a very broad topic and specifying details can clear the fog.\endnote{%
    Which fog?
}

\subsection{Functional Logic Programming Languages}

  Continuing from the previous section, narrowing down the search by considering only multi paradigm declarative
  languages namely, functional logical programming languages.
  By doing so a large amount of information pops up, from articles that give brief description and mentions
  \cite{website:wikiflpl, website:wikiflpllist} to the implementing techniques \cite{website:imlpementingflpl}
  which give a brief overview of the aim and also the backdrop of publications.\endnote{%
    What do you mean by ``backdrop of [the] publications''?
}

  The jackpot however is the fact that there is a dedicated website \cite{website:funclogprog} for the history,
  research and development, existing languages, the literature, the contacts and everything else that one can think
  of for functional logic languages.
  As a matter of fact the holy grail of information is maintained by two of the most important people in the field
  Michael Hanus \cite{website:mhanus} and Sergio Antoy \cite{website:santoy}.


%\end{description}


\section{Literature and Publications}
%\begin{description}
\subsection{Multi Paradigm Languages}
  Possibly one of the most important works towards bringing programming styles together is the book by C.A.R.
  Hoare \cite{hoare1998unifying} which points out that among the large number of programming paradigms and/or
  theories the unification theory serves as a complementary rather than a replacement to relate the universe.
  As as always since we are talking about \progLang{Haskell} we have to\endnote{%
  Use ``must'' in place of ``have to'' where you can.
}\elabel{must-have-to} include monads and unifying theories using
  monads \cite{gibbons2013unifying}.
 

\subsection{Functional Logic Programming Languages}

A recent survey \cite{hanus2007multi} throws light on these hybrid languages. 

One of the most prominent multi paradigm languages in \progLang{Haskell} is \progLang{Curry}
\cite{antoy2010functional}.
The syntax is borrowed from the parent language and so are a lot of the features.
Recapitulating, a functional programming language works on the notion of mathematical functions while a logic
programming language is based on predicate logic.
The strong points of \progLang{Curry} are that the features or basis of the language are general and are visible in
a number of languages like \cite{website:toy}.
The language can play with problems from both worlds.
In a problem where there are no unknowns and/or variables the language behaves like a functional language which is
pattern matching the rules and execute the respective bodies.
In the case of missing information, it behaves like \progLang{Prolog}; a sub-expression \textit{e} is evaluated on
the conditions that it should satisfy which constraint the possible values of \textit{e}.
This brings us to the first important feature of functional logic languages \textit{narrowing}.
The expressions contain \textit{free variables}; simply speaking incomplete information that needs to be
\textit{unified} to a value depending on the constraints of the problem.
The language introduces only a few new constructs to support non determinism and choice.
Firstly, \textit{narrowing} ($\mathtt{=:=}$), which deals with the expressions and unknown values and binds them
with appropriate values.
The next one is the \textit{choice} operator ($\mathtt{?}$) for non-deterministic operations.
Lastly, for unifying variables and values under some conditions, ($\mathtt{\&}$) operator has been provided to add
constraints to the equation.
Putting it all together, it gives us the feel of a logic language for something that looks very much like
\progLang{Haskell}.
Unification is like two way pattern matching and with a similar analogy \progLang{Curry} is a \progLang{Haskell}
that works both ways and hence variables can be on either sides.
Although the language can do a lot but gaps do exist, such as the improvement of narrowing techniques.\endnote{%
  ``Although'' fights with ``but''.  Remove one or the other; and put a comma before ``such as''.
}
 
 
%\end{description}

\section{Some Multi Paradigm Languages}

The list of multi paradigm languages is huge, but in this thesis we will mostly stick to functional logical programming languages. Beginning with functional hybrids, a small project language called \progLang{Virgil} \cite{website:virgil}, combines\endnote{%
  Otherwise you have a sentence fragment.
}
objects to work with functions and procedures.
On similar lines is \progLang{Common Object Lisp System (CLOS)} \cite{website:closwiki}.
This can be justified as object oriented programming has been one of the most dominant styles of programming and
hence even \progLang{Haskell} has one called \progLang{O'Haskell} \cite{website:ohaskell} though it last saw a
release back in 2001.\endnote{%
  The preceding sentence is awkward, although the intent is very good.
  Here is one attempt at rewording it.
  \par\vspace*{-1\baselineskip}
  \begin{quote}
    \slshape
    Combining objects with functions is important
    as object-oriented programming has become one of the most common styles of programming.
    Hence even \progLang{Haskell} has a combined language
    \enparen{called \progLang{O'Haskell}, \cite{website:ohaskell}}, 
    though it last saw a release back in 2001.
  \end{quote}
}
as object oriented programming has been \yyy{one of the most}{a} dominant styles of programming\yyy{ and
hence even}{Even} \progLang{Haskell} has one called \progLang{O'Haskell} \cite{website:ohaskell}\yyy{}{\Large,}\endnote{%
  Add the comma, then remove this endnote.
} though it last saw a
release back in 2001.
Another prominent implementation is \progLang{OCaml} \cite{website:ocamlwiki,website:ocamllang}\yyy{}{\Large,}\endnote{%
  Add the comma, then remove this endnote.
} which adds object
oriented capabilities \yyy{with}{to} a powerful type system and module support.
This is the case with most of the languages in this section hardly a few have survived as the new ones incorporated
the positives of the old.\endnote{%
  I do not understand the preceding sentence at all.
}
As mentioned before\yyy{}{\Large,}\endnote{%
  Add the comma, then remove this endnote.
} one of the most poplar \cite{website:langpop} and widely \yyy{usage}{used} both in academia and industry is
the \progLang{Scala} \cite{website:scala} programming language\xxx{ stands out}.


\section{Functional Logic Programming Languages}

Knowing the amount of literature  on these type of languages, it is fairly easy to say that there have been numerous 
attempts at specifications and implementations.
Sadly though, not many have survived, let alone been successful.
Only the ones that
\begin{inparaenum}[(a)]
\item
  are easily available or
\item
  have an implementation or
\item
  have been cited or referred by other attempts
\end{inparaenum}
have been included, as the list is long and is not the main focus of the thesis.\endnote{%
  This is a good sentence; but I believe that the changes indicated make it clearer.
}
We begin\endnote{%
  The rewording avoids a sentence fragment.
}
with the ones from Australia, which seems to be a popular location for fiddling with
\progLang{Prolog} and merging paradigms.
As of now there have been three popular ones, beginning with \progLang{Neu Prolog}, \cite{website:nue-prolog},
\progLang{Oz (Mozart Programming System)} \cite{website:oz-mozart} and \progLang{Mercury} \cite{website:mercury}.
Delving deeper, the languages feel more like extensions of \progLang{Prolog} rather than hybrids.
To start with \progLang{Mercury} represents a boundary between deterministic and
non-deterministic programs. Similarly,
\progLang{Nue Prolog}\endnote{%
  ``\progLang{Nue Prolog}'' or ``\progLang{Neu Prolog}''?
}
has special support for functions, while \progLang{Oz} gives concurrent constraint programming
plus distributed support, with different function types for goal solving and expression rewriting.\endnote{%
  Are we done with Australia?
  If so, insert something like ``\textsl{Turning now to other languages,}''.
}
\progLang{Escher} \cite{lloyd1999programming:escher} comes very close to \progLang{Haskell} with monads, higher
order functions and lazy evaluation.
Taking a look at \progLang{Prolog} variants, \progLang{Ciao} \cite{website:ciao}; a preprocessor to
\progLang{Prolog} for functional syntax support, \progLang{$\lambda $ Prolog} \cite{website:lambda-prolog} aims at
modular higher order programming with abstract data types in a logical setting, \progLang{Babel}
\cite{website:babel,moreno1992logic, moreno1988babel} combines pure \progLang{Prolog} with a first order functional
notation, \progLang{LIFE} \cite{website:life} is for  logic, inheritance, functions and equations in
\progLang{Prolog} syntax with currying and other features like functional languages and others
\cite{bert1987lpg,malachi1984tablog}.\endnote{%
  This is a good sentence but could be worded more clearly.
  Here is one attempt:
  \textsl{
    We take a look at \progLang{Prolog} variants: \progLang{Ciao} \enparen{\cite{website:ciao}} is a preprocessor
    to \progLang{Prolog} for functional syntax support; \progLang{$\lambda $ Prolog}
    \enparen{\cite{website:lambda-prolog}}
    aims at modular higher order programming with abstract data types in a logical setting;
    \progLang{Babel} \enparen{\cite{website:babel,moreno1992logic, moreno1988babel}} combines pure
    \progLang{Prolog} with a first order functional 
    notation; \progLang{LIFE} \enparen{\cite{website:life}} is for  Logic, Inheritance, Functions and Equations in
    \progLang{Prolog} syntax with currying and other features like functional languages; and there are others
    \enparen{\cite{bert1987lpg,malachi1984tablog}}.}
}

The functional language \progLang{Scheme} is a very popular choice for this sort of a thing.\endnote{%
  What sort of thing?
}
With a book \cite{friedman05reasoned} and an implementation to accompany
\cite{website:kanren,website:minkanren}\endnote{%
  This preceding phrase is not a sentence.
}\elabel{not-a-sentence}\yyy{}{\Large,} 
which seems to have translated into \progLang{Haskell}, 
\cite{website:haskellkanren,website:molog,website:minikanrent}. 

Finally talking about \progLang{Curry}, one of the most popular \progLang{Haskell} based multi paradigm languages with support for deterministic and non-deterministic computations. Contributing to the same there have been some predecessors \cite{website:alf,website:toy}.       


\section{Chapter Recapitulation}

\ifMain
\begin{scope}
  \nolinenumbers
  \enotesize
  \par
  \begin{singlespace}
  \setlength{\parskip}{12pt plus 2pt minus 1pt}
  \theendnotes
  \par
  \end{singlespace}
\end{scope}
\unbcbibliography{bibliography}
\fi

\end{document}
