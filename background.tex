
\documentclass[thesis-solanki.tex]{subfiles}

\ifMain
\externaldocument{thesis-solanki}
\fi
\begin{document}

%----------------------------------------------------------------------------
\chapter{Background}\label{chap:background}
%----------------------------------------------------------------------------

\section{What is this chapter about}

-----------------------------------------------------------------------------

Programming languages fall into different categories also known as ``paradigms''.
They exhibit different characteristics according to the paradigm they fall into.
It has been argued \cite{Krishnamurthi:2008:TPL:1480828.1480846} that
rather than classifying a language into a particular paradigm
\textcolor{fuchsia}{Tt}\endnote{%
  Fix.
}
is
more accurate that a language exhibits a set of characteristics from a
number of paradigms.\endnote{%
  This sentence still needs more crafting.
}
Either way, the broader the scope of a language the more the
expressibility or use it has.

Programming Languages that fall into the same family, in our case declarative programming languages, can be of
different paradigms and can have very contrasting, conflicting characteristics and behaviours.
The two most important ones in the family of declarative languages are the Functional and Logical style of
programming.

Functional Programming, \cite{hughes1989functional} gets its name as the fundamental concept is to apply
mathematical functions to arguments to get results.
A program itself consists of functions and functions only which when applied to arguments produce results without
changing the state that is values on variables and so on.
Higher order functions allow functions to be passed as arguments to other functions.
The roots lie in $\lambda$-calculus \cite{website:lambdacalculuswiki}, a formal system in mathematical logic and
computer science for expressing computation based on function abstraction and application using variable binding
and substitution.
It can be thought as the smallest programming language \cite{rojas2004tutorial}, a single rule and a single
function definition scheme.
In particular there are typed and untyped $\lambda$ calculi.
In the untyped $\lambda$ calculus functions have no predetermined type whereas{\large,} typed lambda calculus puts
restriction on what sort(type) of data can a function work with.
\progLang{Scheme} is based on the untyped variant{\large,} while \progLang{ML} and \progLang{Haskell} are based on typed
$\lambda$ calculus.
Most typed $\lambda$ calculus langauges are based on Hindley-Milner or Damas-Milner or Damas- Hindley-Milner
\yyy{\cite{website:hdmtypesystemwiki}}{(\cite{hindley1969principal,milner1978theory,website:hdmtypesystemwiki})} type system.
The Hindley-Milner like type systems have the ability to give a most general type of a program without any
annotations. 
The algorithm \cite{website:hdmtypesystem} works by initially assigning undefined types to all inputs, next check
the body of the function for operations that impose type constraints and go on mapping the types of each of the
variables, lastly unifying all of the constraints giving the type of the result.\endnote{%
  \david{What is the relevance of this \P{} to the thesis?}\newline
  \mehul{To explain the working, not directly required I guess but since \progLang{Haskell} is statically
    typed}\newline
  \david{Perhaps it is also relevant that this requires unification.}
}

Logical Programming, \cite{spivey1995introduction} on the other hand is based on formal logic.
A program is a set of rules and formul\ae{} in symbolic logic that are used to derive new formulas from the old
ones.
This is done until the one which gives the solution is not derived.

In this thesis we aim to merge the two languages\endnote{%
  ``the two languages''?
  As per the remarks above, the reader is not going to remember what two languages we are talking about.
  Perhaps just dropping ``the'' will fix this.
}
together and produce a result which would exhibit hybrid
properties.
Further on we talk about more about the languages in question and approaches .

The languages to be worked with being \progLang{Haskell} and \progLang{Prolog} respectively.\eref{not-a-sentence}
Some differences include things like, \progLang{ Haskell} uses Pattern Matching while \progLang{Prolog} uses
Unification, \progLang{Haskell} is all about functions while \progLang{Prolog} is on Horn Clause Logic and so
on.\endnote{%
  This \P{} needs rewriting.
}
The languages in question are \progLang{Haskell} and \progLang{Prolog}. Some of the dissimilarities between the languages are,\eref{comma-before-list}
\begin{enumerate}
\item { Haskell} uses Pattern Matching while \progLang{Prolog} uses Unification

\item \progLang{Haskell} is all about functions while \progLang{Prolog} is on Horn Clause Logic
\end{enumerate} 

\progLang{Prolog} \cite{wikiprolog}\yyy{}{\Large,} being one of the most dominant Logic Programming
Languages\yyy{}{\Large,} has  
spawned a number of distributions and is present from academia to industry.  

\progLang{Haskell} is one the most popular \cite{website:langpop} functional languages around and is the 
first language to incorporate Monads \cite{wadler1992comprehending} for safe \textit{IO}. Monads can be 
described as composable computation descriptions \cite{website:monadshaskellorg} . Each monad consists of a 
description of what has action has to be executed, how the action has to be run and how to combine such 
computations. An action can describe an impure or side-effecting computation, for example, \textit{IO} can be 
performed outside the language but can be brought together with pure functions inside in a program resulting in a 
separation and maintaining safety with practicality. \progLang{Haskell} computes results lazily and is strongly 
typed. 

\yyy{The languages taken up}{\progLang{Prolog} and \progLang{Haskell}} are contrasting in nature\yyy{}{\Large,} and
bringing them onto the same plate is tricky.
The differences in typing, execution, working among others lead to an altogether mixed bag of properties.

The target language; \progLang{Prolog} is not \yyy{a}{an} uncommon choice. To prove their power, many language have implemented \cite{swipembedd} a 
modified \progLang{Prolog}\yyy{}{\Large:} for example, \progLang{Scheme} \cite{racklog}, \progLang{Lisp}  
\cite{komorowski1982qlog,robinson1982loglisp,robinson1980loglisp}, \progLang{Java} \cite{wikiprolog, jlog}, 
\progLang{JavaScript} \cite{jscriptlog}\yyy{}{\Large,} and the list \cite{yieldprolog} goes on. 

The selection of languages is not uncommon and this not only the case with \progLang{Haskell,\endnote{%
    I do not understand the sentence before the comma.
}\textsuperscript{,}\endnote{%
    comma splice.
}\elabel{comma-splice}
  Prolog} seems 
to be the all time favourite for \yyy{"}{``}let's implement \progLang{Prolog} in the language X for proving it's power and 
expressibility\yyy{"}{''}. The \progLang{Prolog} language has been partially implemented \cite{swipembedd} in other 
languages \yyy{like}{such as} \progLang{Scheme} \cite{racklog}, \progLang{Lisp}  
\cite{komorowski1982qlog,robinson1982loglisp,robinson1980loglisp}, \progLang{Java} \cite{wikiprolog, jlog}, 
\progLang{JavaScript} \cite{jscriptlog} and the list \cite{yieldprolog} goes on \xxx{and on}.\endnote{%
  This \P{} seems to repeat the preceding \P{}.  Merge them.
}

The technique of embedding is a shallow one.
It is as if the embedded language floats over the host.
Other approaches provide deeper integration between the target and the host.
\yyy{Further on}{Here}\endnote{%
  I am not sure which ``further on'' you are referring to.
  Is it the rest of this \P{}, or is it Chapter~\ref{chap:multiparadigm}?
}
we look at a few.
Over time there has been an approach that branches out, which is Paradigm Integration.
A lot of work has been done on Unifying the Theories of Programming
\cite{DBLP:conf/utp/2006,DBLP:conf/utp/2008,DBLP:conf/utp/2010,DBLP:conf/utp/2012,hoare1998unifying,
  gibbons2013unifying}.
\yyy{All sorts of hybrid}{Hybrid} languages \yyy{which}{that} have characteristics from more than one paradigm are coming into the
mainstream.
One of the more successful attempts is \yyy{\progLang{Scala}\cite{website:scala}}{\progLang{Scala} \cite{website:scala}}. Simply speaking it is like a \textit{functional} 
\progLang{Java} providing side-effect free programming environment along with \xxx{the}
\yyy{\progLang{Java} like}{\progLang{Java}-like} features.

Before moving on, let us take a look at some terms related to the content above.
To begin with Foreign Function Interfaces (FFI) \cite{website:ffiwiki}, a mechanism by which a program written in
one programming language can make use of services written in another.\eref{not-a-sentence}
For example, a function written in \progLang{C} can be called within a program written in \progLang{Haskell} and
vice versa through the FFI mechanism.
Currently the \progLang{Haskell} foreign function interface works only for one language.
Another notable example is the Common Foreign Function Interface (CFFI) \cite{website:commonlisp} for
\progLang{Lisp} which provides fairly complete support for \progLang{C} functions and data.
\yyy{}{As yet another example,}
\progLang{Java} provides the Java Native Interface(JNI) for the working with other languages.
Moreover there are services that provide a common platform for multiple languages to work with each other \xxx{and run
their programs.}
They can be termed as \yyy{multi lingual run times}{multilingual run-times}\endnote{%
  I am not sure which of 
  \begin{compactitem}
  \item \textit{run times}
  \item \textit{run-times}
  \item \textit{runtimes}
  \end{compactitem}
  is correct.
  What do basic O/S texts use?
  ``Multilingual'' is definitely one word.
}
which lay down a common layer for languages to use each others
functions.
An example for this is the Microsoft Common Language Runtime (CLR) \cite{website:clrwiki} which is an
implementation of the Common Language Infrastructure (CLI) standard \cite{website:cliwiki}.

Another important concept is meta programming \cite{website:metaprogwiki}, which involves writing computer programs
that write or manipulate other programs.
The language used to write meta programs is known as the meta language while the the language in which the program
to be modified is written is the object language.
If both of them are the same then the language is said to be reflective.\endnote{%
  I think that this usage of ``reflective'' needs some \yyy{common}{comment}.
  Usually \textit{reflective} refers to run-time access to information about the object language text;
  what you are discussing is compile-time access to the object language.
  ?????
}
\progLang{Haskell} programs can be modified using Template \progLang{Haskell} \cite{website:templatehaskell}, an
extension to the language which provides services to jump between the two types of programs.
The abstract syntax tree used to define a grammar is in the form of a \progLang{Haskell} data type which can be
modified at compile time which allows playing with the code and going back and forth possible.\endnote{%
  The preceding sentence needs fixing.
}

A specific tool used in meta programming is quasi quotation\endnote{%
  I believe that Wikipedia uses ``quasi-quotation'' rather than ``quasi quotation''.
  Check to see what is commonly used.
}
\cite{mainland2007s,haskellquasi,wikiquasi},
which permits
\progLang{Haskell} expressions and patterns to be constructed using domain specific, pro\-gram\-mer-de\-fined concrete
syntax.
For example, consider a particular application that requires a complex data type.
To accommodate the same it has to represented using \progLang{Haskell} syntax and preforming\endnote{%
  ``preforming'' or ``performing''?  
}
pattern matching may
turn into a tedious task.
So having the option of using specific syntax reduces the programmer from this burden and this is where a
quasi-quoter comes into the picture.
Template \progLang{Haskell} provides the facilities mentioned above.
For example, consider the code in Figure~\ref{fig:append-prolog}
in \progLang{Prolog} to append two lists,
\begin{code-list}[h]
\begin{minted}[linenos,frame=lines]{prolog}
append([], X, X).
append([X|Xs], Ys, [X|Zs]) :- append(Xs, Ys, Zs).
\end{minted}    
\vspace*{-0.8\baselineskip}
\caption{Code to ``append'' in \protect\progLang{Prolog}.}
\label{fig:append-prolog}
\end{code-list}
going through the code, the first rule says that and empty list appended with any list results in the list itself.
The second predicate matches the head of the first and the resulting
lists and then \yyy{recurs}{\mbox{recurses}} on the tails. 
The same in \progLang{Haskell},\endnote{%
  \david{Is the point here that templating helps, or what?}\newline
  \mehul{it is just one of the many ways to bring the languages together}\newline
  \david{Say something in the text.}
}
%\begin{minted}[linenos]{haskell}
%append(Ps, Qs, Rs) = (Ps = [] & Qs = Rs) ||
%	(∃ X, Xs, Ys -> Ps = [X|Xs] & 
%		Rs = [X|Ys] & 
%			append(Xs, Qs, Ys))
%\end{minted}  
\inputminted[linenos]{haskell}{append.pl}

Consider the Object Functional Programming Language, \progLang{Scala}
\cite{website:scala}\eref{comma-splice}\textsuperscript{,}\endnote{%
  Should this example be moved up to where you are discussing multi-paradigm languages?
  Wrote something about \progLang{Scala} up there.
}
it is purely functional but with objects and classes.
With the above in mind, coming back to the problem of implementing \progLang{Prolog} in \progLang{Haskell}.\endnote{%
  Sentence fragment.
}
There have been quite a few attempts to ``merge'' the two programming languages from different programming
paradigms.\endnote{% 
  Do you mean
  \begin{quote}
    There have been quite a few attempts to ``merge'' \xxx{the} two programming languages from different programming
    paradigms.
  \end{quote}
  or
  \begin{quote}
    There have been quite a few attempts to ``merge'' \yyy{the}{these} two programming languages\yyy{}{, that are}
    from different programming paradigms.
  \end{quote}
  The word ``the'' confuses me here.
}
The attempts fall into two categories as follows,\eref{comma-before-list}

\begin{enumerate}
\item
  Embedding, where \progLang{Prolog} is merely translated to the host language \progLang{Haskell} or a Foreign
  Function Interface.

\item
  Paradigm Integration, developing a hybrid programming language that is a Functional Logic Programming Language
  with a set of characteristics derived from both the participating languages.
\end{enumerate}

\yyy{The approaches listed above are next in line for discussions}{These two approaches---embedding, and paradigm
  integration---are discussed \dots {\color{dark-green}\footnotesize\sffamily in [specific location]}}.  

\section{Chapter Recapitulation}

\ifMain
\begin{scope}
  \nolinenumbers
  \enotesize
  \par
  \begin{singlespace}
  \setlength{\parskip}{12pt plus 2pt minus 1pt}
  \theendnotes
  \par
  \end{singlespace}
\end{scope}
\unbcbibliography{bibliography}
\fi

\end{document}
