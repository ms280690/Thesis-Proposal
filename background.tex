
\documentclass[thesis-solanki.tex]{subfiles}

\ifMain
\externaldocument{thesis-solanki}
\fi
\begin{document}

%----------------------------------------------------------------------------
\chapter{Background}\label{chap:background}
%----------------------------------------------------------------------------

\section{What this chapter is about}

\noindent\rule{\textwidth}{0.5pt}
%-----------------------------------------------------------------------------

Programming languages fall into different categories also known as ``paradigms''.
They exhibit different characteristics according to the paradigm they fall into.
It has been argued \cite{Krishnamurthi:2008:TPL:1480828.1480846} that
rather than classifying a language into a particular paradigm,
it is
more accurate that a language exhibits a set of characteristics from a
number of paradigms.
The broader the scope of a language, the broader is the versatility in solving problems.

Programming Languages\endnote{%
  \david{What style guide are you using to determine capitalization?}\newline
  \mehul{none at the moment but I will change certain capitals to small}
}\elabel{caps-choices} that fall into the same family, in our case declarative programming languages, can be of
different paradigms and can have very contrasting, conflicting characteristics and behaviours.
The two most important ones in the family of declarative languages are the Functional\eref{caps-choices} and Logical\eref{caps-choices} style of
programming.

Functional Programming\eref{caps-choices}, \cite{hughes1989functional} gets its name as the fundamental concept is to apply
mathematical functions to arguments to get results.
A program itself consists of functions and functions only which when applied to arguments produce results without
changing the state that is values on variables and so on.
Higher order functions allow functions to be passed as arguments to other functions.
The roots lie in $\lambda$-calculi \cite{website:lambdacalculuswiki}, a formal system in mathematical logic and
computer science for expressing computation based on function abstraction and application using variable binding
and substitution.
It can be thought as the smallest programming language \cite{rojas2004tutorial}, a single rule and a single
function definition scheme.
In particular there are typed and untyped $\lambda$-calculi.\endnote{%
  There are a bunch of minor inconsistencies here.
  \begin{inparaitem}
  \item Two sentences up,
    you hyphenate (\(\lambda\)-calculus), but here and in the following
    sentences you drop the hyphen (``\(\lambda\) calculi'').
  \item
    In one place you have ``lambda'' rather than ``\(\lambda\)''.
  \item
    You introduce the plural (\(\lambda\)-calculi), then promptly switch
    back to the singular, even though you are not yet talking about
    specific languages.
  \end{inparaitem}
}
In untyped $\lambda$-calculi functions have no predetermined type, whereas typed $\lambda$-calculi puts
restriction on what sort (type) of data can a function work with.
\progLang{Scheme} is based on the untyped variant, while \progLang{ML} and \progLang{Haskell} are based on typed
$\lambda$-calculi.
Most typed $\lambda$-calculi langauges are based on Hindley-Milner or Damas-Milner or Damas-Hindley-Milner
(\cite{hindley1969principal,milner1978theory,website:hdmtypesystemwiki}) type system.\endnote{%
  I fixed a space here.
  Are 
  \begin{inparaitem}
  \item  Hindley-Milner 
  \item Damas-Milner
  \item Damas-Hindley-Milner
  \end{inparaitem}
  three different names for the same type system; or three different variations on the same idea?
  
}\textsuperscript{,}\endnote{%
  This sentence feels wrong.  I expect either ``\textit{\textsl{the} \dots type system.}'' or ``\textit{\dots type
    system\yyy{}{s}.}'' 
}
The Hindley-Milner\yyy{ }{-}like type systems have the ability to give a most general type \yyy{of}{to} a program
without any annotations. 
The algorithm \cite{website:hdmtypesystem} works by initially assigning undefined types to all inputs, next check
the body of the function for operations that impose type constraints and go on mapping the types of each of the
variables, lastly unifying all of the constraints giving the type of the result.\endnote{%
  \david{What is the relevance of this \P{} to the thesis?}\newline
  \mehul{To explain the working, not directly required I guess but since \progLang{Haskell} is statically
    typed}\newline
  \david{Perhaps it is also relevant that this requires unification.}
  \mehul{unificaiton is explained in proto1 and hints have been dropped
    at other places. Do you want me to write a short snipped
    here?}\newline
  \david{``snipped'' or ``snippet''?  You can just add a sentence like
    ``\textsl{This is, in fact, an instance of the unification algorithm
      that we discuss in a different context in Chapter~\ref{proto1}}.''.
  }
}

Logic Programming\eref{caps-choices}, \cite{spivey1995introduction} on the other hand is based on formal logic.
A program is a set of rules and formul\ae{} in symbolic logic that are used to derive new formulas from the old
ones.
This is done until the one which gives the solution is not derived.

\david{In
  the following \P's there seem to be a number of instances of material repeated twice with an older version
  followed by a newer version.  I find it hard to imagine what the final result is going to be, so I am going to
  cut material in the commit that introduces this comment, and let you see if you agree that I've got it right. 
}

In this thesis we aim to merge two languages
together and produce a result which exhibits hybrid
properties.\endnote{%
  Remove this sentence, and merge with the following \P.
}

The languages in question are \progLang{Haskell} and \progLang{Prolog}. These two languages come from respective the functional programming and logical programming branches of the
    declarative language group.\endnote{%
  Insert a sentence here linking these two languages with the \P's above.
  Use something like
  \begin{quote}\slshape
    These two languages come from respective the functional programming and logical programming branches of the
    declarative language group.
  \end{quote}
}
Some of the dissimilarities between the languages are:
\begin{enumerate}
\item { Haskell} uses \haskellConstruct{pattern matching} while \progLang{Prolog} uses \prologConstruct{unification}.

\item \progLang{Haskell} is all about functions while \progLang{Prolog} is on Horn clause logic.
\end{enumerate} 

\progLang{Prolog} \cite{wikiprolog}, being one of the most dominant logic programming
languages, has  
spawned a number of distributions and is present from academia to industry.  

\progLang{Haskell} is one the most popular \cite{website:langpop} functional languages around and is the 
first language to incorporate \haskellConstruct{monads} \cite{wadler1992comprehending} for safe input and output.
\haskellConstruct{Monads}\endnote{%
  Here ``monad'' is an (admittedly technical) English word.
  It doesn't need special marking.
}
can be 
described as composable computation descriptions \cite{website:monadshaskellorg}\yyy{ }{}.\endnote{%
  Remove the space before the period.
}
Each \haskellConstruct{monad}\endnote{%
  See the preceding endnote.
}
consists of a description of what has action has to be executed, how the action has to be run and how to combine
such computations.
An action can describe an impure or side-effecting computation, for example, input and output can be performed
outside the language but can be brought together with pure functions inside in a program resulting in a separation
and maintaining safety with practicality.
\progLang{Haskell} computes results lazily and is strongly typed.

\progLang{Prolog} and \progLang{Haskell} are contrasting in nature, and
bringing them into the same environment is tricky.
The differences in typing, execution, working among others lead to an altogether mixed bag of properties.


The selection of the target language is not uncommon:
  \progLang{Prolog} seems 
to be the all time favourite for ``let's implement \progLang{Prolog} in
the language X for proving
its\endnote{%
  Please be careful about ``it's'' and ``its''.  Remove this endnote when you are confident that you have checked
  them all.
}
power and 
expressibility''. The \progLang{Prolog} language has been partially implemented \cite{swipembedd} in other 
languages such as \progLang{Scheme} \cite{racklog}, \progLang{Lisp}  
\cite{komorowski1982qlog,robinson1982loglisp,robinson1980loglisp}, \progLang{Java} \cite{wikiprolog, jlog}, 
\progLang{JavaScript} \cite{jscriptlog} and the list \cite{yieldprolog} goes on.

The technique of embedding is a shallow one.
It is as if the embedded language floats over the host language.
Other approaches provide deeper integration between the target and the host.
Here\endnote{%
  I am not sure which ``further on'' you are referring to.
  Is it the rest of this \P{}, or is it Chapter~\ref{chap:multiparadigm}?
}
we look at a few.
Over time there has been an approach that branches out, which is paradigm integration.
A lot of work has been done on Unifying the Theories\eref{caps-choices} of Programming\eref{caps-choices}
\cite{DBLP:conf/utp/2006,DBLP:conf/utp/2008,DBLP:conf/utp/2010,DBLP:conf/utp/2012,hoare1998unifying,
  gibbons2013unifying}.
Hybrid languages that have characteristics from more than one paradigm are coming into the
mainstream.
One of the more successful attempts is \progLang{Scala} \cite{website:scala}. Simply speaking it is like a \textit{functional} 
\progLang{Java} providing side-effect free programming environment along with
\progLang{Java}-like features.

Before moving on, let us take a look at some terms related to the content above.
To begin with foreign function interfaces (FFI) \cite{website:ffiwiki}, a mechanism by which a program written in
one programming language can make use of services written in another.\eref{not-a-sentence}
For example, a function written in \progLang{C} can be called within a program written in \progLang{Haskell} and
vice versa through the FFI mechanism.
Currently the \progLang{Haskell} foreign function interface works only for one language.
Another notable example is the common foreign function interface (CFFI) \cite{website:commonlisp} for
\progLang{Lisp} which provides fairly complete support for \progLang{C} functions and data.
As yet another example,
\progLang{Java} provides the java native interface(JNI) for the working with other languages.
Moreover there are services that provide a common platform for multiple languages to work with each other. 
They can be termed as multilingual run-times\endnote{%
  I am not sure which of 
  \begin{compactitem}
  \item \textit{run times}
  \item \textit{run-times}
  \item \textit{runtimes}
  \end{compactitem}
  is correct.
  What do basic O/S texts use?
  ``Multilingual'' is definitely one word.
  \Verb!https://en.wikipedia.org/wiki/Run_time_(program_lifecycle_phase)!
}
which lay down a common layer for languages to use each others
functions.
An example for this is the Microsoft common language runtime (CLR) \cite{website:clrwiki} which is an
implementation of the common language infrastructure (CLI) standard \cite{website:cliwiki}.

Another important concept is meta programming \cite{website:metaprogwiki}, which involves writing computer programs
that write or manipulate other programs.
The language used to write meta programs is known as the meta language while the the language in which the program
to be modified is written is the object language.
If both of them are the same then the language is said to be reflective.\endnote{%
  I think that this usage of ``reflective'' needs some comment.
  Usually \textit{reflective} refers to run-time access to information about the object language text;
  what you are discussing is compile-time access to the object language.\newline
  \david{Is this your \mehul?????}?}
}
\progLang{Haskell} programs can be modified using Template \progLang{Haskell} \cite{website:templatehaskell}, an
extension to the language which provides services to jump between the two types of programs.
The abstract syntax tree used to define a grammar is in the form of a \progLang{Haskell} data type which can be
modified at compile time which allows playing with the code and going back and forth possible.\endnote{%
  The preceding sentence needs fixing.
}

A specific tool used in meta programming is quasi-quotation\endnote{%
  I believe that Wikipedia uses ``quasi-quotation'' rather than ``quasi quotation''.
  Check to see what is commonly used.
}
\cite{mainland2007s,haskellquasi,wikiquasi},
which permits
\progLang{Haskell} expressions and patterns to be constructed using domain specific, pro\-gram\-mer-de\-fined concrete
syntax.
For example, consider a particular application that requires a complex data type.
To accommodate the same it has to represented using \progLang{Haskell} syntax and performing\endnote{%
  ``preforming'' or ``performing''?
  \mehul{performing}

}
pattern matching may
turn into a tedious task.
So having the option of using specific syntax reduces the programmer from this burden and this is where a
quasi-quoter comes into the picture.
Template \progLang{Haskell} provides the facilities mentioned above.
For example, consider the code in Figure~\ref{fig:append-prolog}
in \progLang{Prolog} to append two lists,
\begin{code-list}[h]
\begin{minted}[linenos,frame=lines]{prolog}
append([], X, X).
append([X|Xs], Ys, [X|Zs]) :- append(Xs, Ys, Zs).
\end{minted}    
\vspace*{-0.8\baselineskip}
\caption{Code to ``append'' in \protect\progLang{Prolog}.}
\label{fig:append-prolog}
\end{code-list}
going through the code, the first rule says that and empty list appended with any list results in the list itself.
The second predicate matches the head of the first and the resulting
lists and then recurses on the tails. 
The same in \progLang{Haskell},\endnote{%
  \david{Is the point here that templating helps, or what?}\newline
  \mehul{it is just one of the many ways to bring the languages together}\newline
  \david{Say something in the text.}
}
%\begin{minted}[linenos]{haskell}
%append(Ps, Qs, Rs) = (Ps = [] & Qs = Rs) ||
%	(âˆƒ X, Xs, Ys -> Ps = [X|Xs] & 
%		Rs = [X|Ys] & 
%			append(Xs, Qs, Ys))
%\end{minted}  
\inputminted[linenos]{haskell}{append.pl}

Consider the Object Functional Programming Language\eref{caps-choices}, \progLang{Scala}
\cite{website:scala}.\endnote{%
  Should this example be moved up to where you are discussing multi-paradigm languages?
  Wrote something about \progLang{Scala} up there.
}
It is purely functional but with objects and classes.
With the above in mind, coming back to the problem of implementing \progLang{Prolog} in \progLang{Haskell}.\endnote{%
  Sentence fragment.
}
There have been quite a few attempts to ``merge'' these two programming languages that are from different programming
paradigms.\endnote{% 
  Do you mean
  \begin{quote}
    There have been quite a few attempts to ``merge'' \xxx{the} two programming languages from different programming
    paradigms.
  \end{quote}
  or
  \begin{quote}
    There have been quite a few attempts to ``merge'' \yyy{the}{these} two programming languages\yyy{}{, that are}
    from different programming paradigms.
  \end{quote}
  The word ``the'' confuses me here.
  \mehul{There have been quite a few attempts to ``merge'' \yyy{the}{these} two programming languages\yyy{}{, that are}
    from different programming paradigms.}
}
The attempts fall into two categories as follows:

\begin{enumerate}
\item
  Embedding, where \progLang{Prolog} is merely translated to the host language \progLang{Haskell} or a foreign
  function interface.

\item
  Paradigm integration, developing a hybrid programming language that is a functional logic programming language
  with a set of characteristics derived from both the participating languages.
\end{enumerate}

\yyy{The approaches listed above are next in line for discussions}{These two approaches---embedding, and paradigm
  integration---are discussed \dots {\color{dark-green}\footnotesize\sffamily in [specific location]}}.  

\section{Chapter Recapitulation}

\ifMain
\begin{scope}
  \nolinenumbers
  \enotesize
  \par
  \begin{singlespace}
  \setlength{\parskip}{12pt plus 2pt minus 1pt}
  \theendnotes
  \par
  \end{singlespace}
\end{scope}
\unbcbibliography{bibliography}
\fi

\end{document}
