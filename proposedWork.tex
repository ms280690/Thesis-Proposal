\documentclass[thesis-solanki.tex]{subfiles}


\ifMain
\externaldocument{thesis-solanki}
\fi
\begin{document}

%-----------------------------------------------------------------------------
\chapter{Current and Accomplished Work}\label{chap:proposedWork}
%-----------------------------------------------------------------------------

\textcolor{blue}{\textsl{I suspect that the title of this chapter needs to change.}}

\section{What is this chapter about}\label{sec:what-this-chapter:proposedWork}

\textcolor{blue}{\textsl{I need this information.
    I do not know what you are trying to do here.
}}

This chapter discusses the current work in done in embedding programming languages. Specifically speaking embedding \progLang{Prolog} in 
\progLang{Haskell}. We analyze the current implementations and provide insights into the contributions of this thesis. 

%-----------------------------------------------------------------------------
\noindent\rule{\textwidth}{0.5pt}


\section{\protect{Existing Work by Others}}

There have been several attempts at embedding \progLang{Prolog} into \progLang{Haskell}{\large,} which are
discussed below{\large,} along with their shortcomings.

\begin{enumerate}
\item
  Very few embedded implementations exist which offer a perspective into the job at hand.\endnote{%
    What is ``the job at hand''?
    What is `` a perspective into the job at hand''?
    See \textit{p.}~\pageref{sec:list-colloquialisms}.
}
  One of the earliest implementations \cite{website:mini-prolog-hugs98} is for an older specification of
  \progLang{Haskell} called \progLang{Haskell 98} \texttt{\bfseries{hugs}}.
  It is more of a proof of concept providing a mechanism to include variable search strategies in order to produce
  a result.
  Another implementation \cite{website:takashi-workplace} based of it simplifies the notation to a list format.
  Nonetheless, both implementations lack simplicity and support for basic \progLang{Prolog} features such as
  \textit{cuts, fails, assert} among others.

\begin{comment}
\item
  Only two embeddings exist, one of them is old and made for \texttt{\bfseries{hugs}} a functional programming
  system based on the \progLang{Haskell 98} specification.
  It is complex and also lacks a lot of \progLang{Prolog} like\eref{language-like} features including \textit{cuts, fails, assert}
  among others.
  The second one is based off the first one to make it simple but it loses the variable search strategy support
  which allows the programmer to choose the manner in which a solution is produced.
\end{comment}

\item
  The papers that try to take the above further are also few in number and do not have any implementations with the
  proposed concepts \yyy{}{(see }\cite{spivey1999embedding, seres1999algebra, seres2001algebra, spivey2000functional, seres2000optimisation}\yyy{}{)}.
  Moreover, none of them are complete and most lack many practical parts of \progLang{Prolog}.

\item
  In the case of libraries, a few exist,\endnote{%
    comma splice.
}\elabel{comma-splice} most are old and are not currently maintained or updated.
  Many provide only a shell through which one has to
  do\eref{must-have-to} all the work, which is synonymous with the
  embeddings mentioned above.
  Some are \xxx{far} more feature rich than others\yyy{ that is with
    some}{; that is, some have} practical \progLang{Prolog} concepts,
  but are \yyy{}{still} not complete.\endnote{%
    Did I get your sense?
}

\item
  Moreover, none of the above have natural list support that exist\endnote{%
    ``exist'' or ``exists''?
}
  in \progLang{Prolog}.\endnote{%
    \david{What does this point mean?}
    \mehul{I would have to think; I do not remember.}
}
\end{enumerate}

And as far as the idea of merging paradigms goes, it is not the main focus of this thesis and can be more of an
``add-on''.\eref{no-and}
A handful of crossover hybrid languages based on \progLang{Haskell} exist, \progLang{Curry} \cite{website:curry}
being the prominent one.
Moving away from \progLang{Haskell} and exploring other languages from different paradigms, a respectable number of
crossover implementations exist but again most of them have faded out.\endnote{%
  \S~\ref{sec:what-this-chapter:proposedWork} says that this chapter is about embedding programming languages.
  You appear to have wandered off topic.
}

As discussed in the sections above,\endnote{%
  Which sections above?  Use \macroName{label} and \macroName{ref}
  to say precisely which.
}
either an embedding or an integration approach is taken up for programming
languages to work together.
So, there is either a very shallow approach that does not utilize the constructs available in the host language and
results in a mere translation of the characteristics, or the other is a fairly complex process which results in
tackling the conflicting nature of different programming paradigms and languages, resulting in a toned-down
compromised language that takes advantages of neither paradigms.\endnote{%
  I am uncertain as to the tone.
  Words like ``very'', ``mere'', and so on seem overly argumentative.
}
Mostly\yyy{}{\Large,} the trend is to build a library for extension to replicate the features as an add on.\endnote{%
  What is the point of this \P{} relative to the overall thesis?
}

Taking into consideration above, there is quite some room for improvement and additions.
\section{Proposal Contributions}

Moving onto what this thesis shall explore, first thing's first a complete, fully functional library which comes
close to a \progLang{Prolog} like\eref{language-like} language and has practical abilities to carry out real-world tasks.
They include predicates like\eref{such-as-like} \unknownLabel{cut}\endnote{%
  Write macros like \macroName{progLang} for the various classes
  of special symbols in your thesis, and then apply them to words like
  ``fail'', which when used as a \progLang{Prolog} word, should be
  typeset as \texttt{\char`\\prologCode\char`\{fail\char`\}}, or some such.
}\elabel{text-kind}
, \markWord{assert}, \markWord{fail}, \markWord{setOf}, \markWord{bagOf} among others.
This \yyy{would form}{forms}\endnote{%
  Not ``would form''.  ``forms'' perhaps.  You are talking about what \textbf{is} in the thesis.
}
the first stage of the implementation.
Secondly, exploring aspects such as \markWord{assert} and database capabilities.\endnote{%
  \david{Strike this?}\newline
  \mehul{well we/ the library does some of this right ?}
}\textsuperscript{,}\endnote{%
  This is not a complete sentence.
}
A third question to address is the accommodation of input and output, specifically dealing with the \markWord{IO
  Monad} in \progLang{Haskell} with \progLang{Prolog} \markWord{IO}.\endnote{%
  Make this clearer. Perhaps\par\vspace{-1\baselineskip}
  \begin{quote}\slshape
    A third question to address is the accommodation of input and
    output.
    More specifically, \progLang{Prolog}
    uses \textit{ad hoc} side effects to accomplish input and output,
    whereas \progLang{Haskell} forces the use of the \unknownLabel{IO
      Monad}, making it difficult to model the former in the latter.
    \enparen{See Chapter~\ref{proto3}.}
  \end{quote}
  \vspace{-1\baselineskip}
  \noindent or something simlar.
}
Moreover, \progLang{Prolog} is an untyped language which allows lists with elements of different types to be
created.
Something like this is not by default in \progLang{Haskell}.
Hence syntactic support for the same is the next question to address.
Furthermore, experimenting with how programs expressed with same declarative meaning differ operationally.\eref{not-a-sentence}
Lastly, how would characteristics of hybrid languages fit into and play a role in an embedded setting.\eref{not-a-sentence}


\section{Improved Contributions}
\begin{enumerate}
\item
  Most languages have a recursive abstract syntax which restricts the eDSL\endnote{%
    Have we defined ``eDSL'' yet?  If not, write
    ``\textsl{embedded, domain-specific language \enparen{eDSL}}''.
}
  in terms of its capability to
  \textit{open up} the language{\large,} i.e{\large,}
  to include meta syntactic variables, custom quantifiers and logic.
  (\chapterReference{proto1}{Prototype 1}) provides a methodology to convert a language whose recursive abstract
  syntax is represented by a tree into a non-recursive version whose fixed point is isomorphically equivalent to
  the original type.
  One of the outcomes is a producing a polymorphically typed embedded language within \progLang{Haskell}{\Large.}

  To test it out we adopt the closed \progLang{Prolog} like\eref{language-like} language defined in \cite{prolog-lib} and open it up.
  And for the unification part we use \cite{unification-fd-lib}, which provides a generic unification algorithm
  implementation encapsulated into a monad.\endnote{%
    See \textit{p.}~\pageref{item:no-and}, item~\ref{item:no-and}.
}\elabel{no-and}

\item
  (\chapterReference{proto2.1}{Prototype 2}) does the what a \progLang{Prolog} query resolver would do given a
  query and a knowledge base.
  The mechanism for the same is adopted from \cite{prolog-lib}.
  The embedded language is modified as per the procedure in (\chapterReference{proto1}{Prototype 1}) and the
  monadic unification part is plugged into the existing architecture to demonstrate that it is independent of the
  other components.
  Lastly the result is converted into the original language via a translate function.

\item
  (\chapterReference{proto3}{Prototype 3}) demonstrates the modularity of the unification process of the query
  resolver with multiple search strategies.

\item
  (\chapterReference{proto4}{Prototype 4}) throws light on how IO operations can be embedded into the abstract
  syntax of a DSL which when interpreted would produce output consisting of a pure set of instructions irrespective
  of the nature of the construct.
  The effects are only produced only when the actions are executed.
\end{enumerate}



\section{Thesis Improved Contributions}

\begin{enumerate}
\item Prototype 1 does
flattening language
opening up the language (binding monad)
adding custom variables
monadic unification (stuff happens in a bubble)
rec type $\rightarrow$ non rec type $\rightarrow$ fix non rec type isomorphically == rec type

You can make an Flatterm int

but you cannot make term int

adding quantifiers


\item Prototype 2 does
extends current prolog-0.2.0.1
this is to show that we can plug out approach into existing implementation and things work

\item Prototype 3 does
variable search strategy
what ever method you do for searching at the point of unification you can do it with our approach

\item Prototype 4 does
how can io be squeezed into this model where whenever the resolver encounters an io operation it generates a thunk (sort of unsolved
statement) which when executed would result in a side effect but till that point every thing is pure

\end{enumerate}


\section{What work was done in terms of points}
\begin{enumerate}
\item Literature review on eDSL's.

\item Short survey on multi paradigm declarative languages.

\item Accumulated and evaluated \progLang{Prolog} in \progLang{Haskell}.

\item Defined a procedure to open up a language starting from a generic recursive abstract syntax.

\item Made a few libraries to work together.

\item Some stuff for monadic unification.

\item Something to show it was modular and independent of the original grammar.

\item
  Something to show that the unification part is independent of the search strategy and hence multiple ones can be
  used, possibly simultaneously to find a solution.

\item
  Creating a micro language to represent and encapsulate IO operation in an eDSL so that the it remains pure even
  after interpretation and only produces side effects when the action is actually executed and hence in some way it
  can be controlled.

\end{enumerate}


\section{Chapter Recapitulation}


\ifMain
\begin{scope}
  \nolinenumbers
  \enotesize
  \par
  \begin{singlespace}
  \setlength{\parskip}{12pt plus 2pt minus 1pt}
  \theendnotes
  \par
  \end{singlespace}
\end{scope}
\unbcbibliography{bibliography}
\fi

\end{document}
