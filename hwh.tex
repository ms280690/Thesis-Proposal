\documentclass[thesis-solanki.tex]{subfiles}

\ifMain
\externaldocument{thesis-solanki}
\fi
\begin{document}

% ---------------------------------------------------------------------------
\chapter{Haskell or Why Haskell ?}\label{chap:hwh}
% ---------------------------------------------------------------------------


\section{What is this chapter about}

-----------------------------------------------------------------------------


In this chapter we discuss the properties of \progLang{Haskell}

This chapter discusses the properties of the host language \progLang{Haskell} and mainly the feature set it
provides for embedding domain specific languages(EDSLs).

\begin{enumerate}

\item Why a Functional Language?

\item
  \progLang{Haskell} as a functional programming language Haskell is an advanced purely-functional programming
  language.
  In particular, it is a polymorphically statically typed, lazy, purely functional language
  \cite{website:haskellwiki}.
  It is one of the popular functional programming languages \cite{website:langpop}.
  \progLang{Haskell} is widely used in the industry \cite{website:haskellinindustry}.

  Shifting a bit to Embedded Domain Specific Languages (EDSLs) such as Emacs LISP.
  Opting for embedding provides a ``shortcut'' to create a language which may be designed to provide specific
  functionality.
  Designing a language from scratch would require writing a parser, code generator / interpreter and possibly a
  debugger, not to mention all the routine stuff that every language
  needs like\eref{such-as-like} variables, control structures and 
  arithmetic types.
  All of the aforementioned are provided by the host language; in this case \progLang{Haskell}.
  Examples for the same can be found here \cite{jones2001composing, meyer2008eiffel} which talk about introducing
  combinator libraries for custom functionality.

  The flip side of the coin is that the host language enforces certain aspects and properties of the eDSL and hence
  might not be exact to specification, all required constructs cannot be implemented due to constraints, programs
  could be difficult to debug since it happens at the host level and so on.

\item Looking at \progLang{Haskell} as a tool for embedding domain specific languages \cite{website:paulspontifications}

\begin{enumerate}
\item Monads
\newline
Control flow defines the order/ manner of execution of statements in a pro\-gram \cite{website:controlflowwiki}.
The specification is set by the programming language.
Generally, in the case of imperative languages the control flow is sequential while for a functional language is
recursion \cite{website:controlflowdalhousie}.
For example, \progLang{Java} has a top down sequential execution approach.
The declarative style consists of defining components of programs i.e.
computations not a control flow \cite{website:declarativeprogrammingwiki}.

This is where \progLang{Haskell} shines by providing something called a \textit{monad}.
Functional Programming Languages define computations which then need to be ordered in some way to form a
combination\cite{website:monadascomputation}.
A monad gives a bubble within the language to allow modification of control flow without affecting the rest of the
universe.
This is especially useful while handling side effects.

A related topic would be of persistence languages, architectures and data structures.
Persistent programming is concerned with creating and manipulating data in a manner that is independent of its
lifetime \cite{morrison1990persistent}.
A persistent data structure supports access to multiple versions which may arise after modifications
\cite{driscoll1986making, website:persistentdatastructuresmit}.
A structure is partially persistent if all versions can be accessed but only the current can be modified and fully
persistent if all of them can be modified.

Coming back to control flow; for example, implementing backtracking in an imperative language would mean undoing
side effects which even \progLang{Prolog} is not able to do since the asserts and retracts cannot be undone.
In \progLang{Haskell}, a monad defines a model for control flow and how side effects would propagate through a
computation from step to step or modification to modification.
And \progLang{Haskell} allows creation of custom monads relieving the burden of dealing with a fixed model of the
host language.\eref{no-and}

\item Lazy Evaluation
\newline
Another property of \progLang{Haskell} is laziness or lazy evaluation which means that nothing is evaluated until
it is necessary.
This results in the ability to define infinite data structures because at execution only a fragment is used
\cite{website:haskelllazinesswiki}.

\end{enumerate}
\end{enumerate}







\section{Chapter Recapitulation}



\ifMain
\begin{scope}
  \nolinenumbers
  \enotesize
  \par
  \begin{singlespace}
  \setlength{\parskip}{12pt plus 2pt minus 1pt}
  \theendnotes
  \par
  \end{singlespace}
\end{scope}
\unbcbibliography{bibliography}
\fi


\end{document}
