\documentclass[thesis-solanki.tex]{subfiles}

\ifMain
\externaldocument{thesis-solanki}
\fi
\begin{document}

% ---------------------------------------------------------------------------
\chapter{\progLang{Haskell}}\label{chap:hwh}
% ---------------------------------------------------------------------------


\section{About this chapter}
This chapter discusses \progLang{Haskell} as a functional language and its features which assist in embedding domain specific languages.

\section{Functional languages}

\section{Embedded domain specific languages}
  Shifting a bit to embedded domain specific languages (eDSLs) such as \progLang{Emacs LISP}.
  Opting for embedding provides a ``shortcut'' to create a language which may be designed to provide specific
  functionality.
  Designing a language from scratch would require writing a parser, code generator / interpreter and possibly a
  debugger, not to mention all the routine stuff that every language
  needs such as variables, control structures and 
  arithmetic types.
  All of the aforementioned are provided by the host language; in this case \progLang{Haskell}.
  Examples for the same can be found here \cite{jones2001composing, meyer2008eiffel} which talk about introducing
  combinator libraries for custom functionality.

  The flip side of the coin is that the host language enforces certain aspects and properties of the eDSL and hence
  might not be exact to specification, all required constructs cannot be implemented due to constraints, programs
  could be difficult to debug since it happens at the host level and so on.


\section{\progLang{Haskell}}
\progLang{Haskell} as a functional programming language \progLang{Haskell} is an advanced purely-functional programming
  language.
  In particular, it is a polymorphically statically typed, lazy, purely functional language
  \cite{website:haskellwiki}.
  It is one of the popular functional programming languages \cite{website:langpop}.
  \progLang{Haskell} is widely used in the industry \cite{website:haskellinindustry}.

\subsection{Monads}
Control flow defines the order/ manner of execution of statements in a pro\-gram \cite{website:controlflowwiki}.
The specification is set by the programming language.
Generally, in the case of imperative languages the control flow is sequential while for a functional language is
recursion \cite{website:controlflowdalhousie}.
For example, \progLang{Java} has a top down sequential execution approach.
The declarative style consists of defining components of programs i.e.,
computations not a control flow \cite{website:declarativeprogrammingwiki}.

This is where \progLang{Haskell} shines by providing something called a \textit{monad}.
Functional programming languages
define computations which then need to be ordered in some way to form a
combination \cite{website:monadascomputation}.
A monad gives a bubble within the language to allow modification of control flow without affecting the rest of the
universe.
This is especially useful while handling side effects.

A related topic would be of persistence languages, architectures and data structures.
Persistent programming is concerned with creating and manipulating data in a manner that is independent of its
lifetime \cite{morrison1990persistent}.
A persistent data structure supports access to multiple versions which may arise after modifications
\cite{driscoll1986making, website:persistentdatastructuresmit}.
A structure is partially persistent if all versions can be accessed but only the current can be modified and fully
persistent if all of them can be modified.

Coming back to control flow; for example, implementing backtracking in an imperative language would mean undoing
side effects which even \progLang{Prolog} is not able to do since the asserts and retracts cannot be undone.
In \progLang{Haskell}, a monad defines a model for control flow and how side effects would propagate through a
computation from step to step or modification to modification.
\progLang{Haskell} allows creation of custom monads relieving the burden of dealing with a fixed model of the
host language.

\subsection{Lazy evaluation}
Another property of \progLang{Haskell} is laziness or lazy evaluation which means that nothing is evaluated until
it is necessary.
This results in the ability to define infinite data structures because at execution only a fragment is used
\cite{website:haskelllazinesswiki}.



\section{Chapter recapitulation}
Recapitulating, this chapter provided information on \progLang{Haskell} as a tool for embedding domain specific languages.


\ifMain
\begin{scope}
  \nolinenumbers
  \enotesize
  \par
  \begin{singlespace}
  \setlength{\parskip}{12pt plus 2pt minus 1pt}
  \theendnotes
  \par
  \end{singlespace}
\end{scope}
\unbcbibliography{bibliography}
\fi


\end{document}
