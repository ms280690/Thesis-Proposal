\documentclass[thesis-solanki.tex]{files}


\begin{document}

\chapter{Prototype 3}{\label{proto3}}


\section{About this chapter}
This chapter discusses the procedure to infuse multiple search strategies into a \progLang{Prolog} query resolver with monadic unification. 
The base implementation for this prototype is \codeLibrary{Mini \progLang{Prolog}} \cite{website:mini-prolog-hugs98}.


\section{\codeLibrary{Mini \progLang{Prolog}} \cite{website:mini-prolog-hugs98} architecture}
The \codeLibrary{Mini \progLang{Prolog}} is based on an older specification of \progLang{Haskell} called \codeLibrary{Hugs 98}. The architecture of
the library is described in the Figure~\ref{fig:miniprlgarchitecture}. The main components are as follows:

\begin{enumerate}
\item the language itself,

\item multiple search strategies used by the query resolver,

\item a parser,

\item a unification mechanism,

\item an interpreter,

\item a knowledge base, and

\item a REPL.  
\end{enumerate}

The main highlight of this implementation is the fact that the query resolver can work with multiple search strategies decided at runtime. A query request 
will consist of the query itself i.e. the terms to be unified, a knowledge base storing the clauses, the unification procedure and finally a user provided 
search strategy. 


\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{miniprologhugs_architecture.png}
%\vspace*{1cm}
  \caption{Mini \progLang{Prolog} architecture}
  \label{fig:miniprlgarchitecture}
\end{figure}


\section{Prototype architecture}

The focus of this prototype is to embed the language modification procedure and monadic unification into \cite{website:mini-prolog-hugs98} so to further 
prove the generality and modularity of the approach from the previous prototypes. 
The architecture for this prototype is beautifully illustrated by Figure~\ref{fig:architecture-proto-3}. 

\begin{figure}[H]
  \includegraphics[width=1\textwidth]{proto3_architecture_revised.png}
\vspace*{-1cm}
  \caption{Architecture of Prototype 3}
  \label{fig:architecture-proto-3}
\end{figure}

Since we are aiming for modularity most components in the figure above are untouched. The abstract syntax grammar is modified for the benefits and for it
to conform to the \codeLibrary{unification-fd} \cite{unification-fd-lib}.
Looking at the center of the figure you will find \textit{query}. This component takes as input the terms to be unified in modified language form, a 
search strategy, the knowledge base and the monadic unifier to return a list of substitutions are required by the library. Each of these components will be
discussed in the sections to come.   


\section{Search strategies}
The base implementation used for this prototype is \cite{website:mini-prolog-hugs98} and the sections below describe the search
strategies.

\subsection{Stack engine}
The stack based engine maintains a stack of triples \haskellConstruct{(s,goal,alts)}
corresponding to backtrack points, where \haskellConstruct{s} is the substitution at that
point, goal is the outstanding goal and \haskellConstruct{alts} is a list of possible ways
of extending the current proof to find a solution.  Each member of alts
is a pair \haskellConstruct{(tp,u)} where \haskellConstruct{tp} is a new goal that must be proved and \haskellConstruct{u} is
a unifying substitution that must be combined with the substitution \haskellConstruct{s}.
The list of relevant clauses at each step in the execution is produced
by attempting to unify the head of the current goal with a suitably
renamed clause from the database.

Listing~\ref{tab:stackengineminiprlg}

\begin{code-list}[H]
\begin{singlespace}
\inputminted[linenos, firstline=29, lastline=56]{haskell}{haskell-proto3-sudsy-woe.hs}
\end{singlespace}
\caption{Stack engine from \cite{website:mini-prolog-hugs98}}
\label{tab:stackengineminiprlg}
\end{code-list}

\subsection{Pure engine}
 Each node in a \haskellConstruct{Prooftree} corresponds to:
 either: a solution to the current goal, represented by \haskellConstruct{Done s}, where \haskellConstruct{s}
         is the required substitution
 or:     a choice between a number of trees \haskellConstruct{ts}, each corresponding to a
         proof of a goal of the current goal, represented by \haskellConstruct{Choice ts}.
         The proof tree corresponding to an unsolvable goal is \haskellConstruct{Choice []} 

Listing~\ref{tab:pureengineminiprlg}

\begin{code-list}[H]
\begin{singlespace}
\inputminted[linenos, firstline=26, lastline=46]{haskell}{haskell-proto3-absurd-silicon.hs}
\end{singlespace}
\caption{Pure engine from \cite{website:mini-prolog-hugs98}}
\label{tab:pureengineminiprlg}
\end{code-list}

\subsection{Andorra engine}
Listing~\ref{tab:andorraengineminiprlg}

\begin{code-list}[H]
\begin{singlespace}
\inputminted[linenos, firstline=29, lastline=64]{haskell}{haskell-proto3-diatomic-unbank.hs}
\end{singlespace}
\caption{Andorra engine from \cite{website:mini-prolog-hugs98}}
\label{tab:andorraengineminiprlg}
\end{code-list}


\section{Language}
\subsection{Current language}
Listing~\ref{tab:miniprlglang}
\begin{code-list}[H]
\begin{singlespace}
  \inputminted[linenos, firstline=24, lastline=37]{haskell}{haskell-proto3-butter-chicken.hs}
\end{singlespace}
\caption{Current abstract syntax grammar in \cite{website:mini-prolog-hugs98}}
\label{tab:miniprlglang}
\end{code-list}

\subsection{Language modification}
Listing~\ref{tab:miniprlglangmod}

\begin{code-list}[H]
\begin{singlespace}
  \inputminted[linenos, firstline=64, lastline=87]{haskell}{haskell-proto3-uplift-apart.hs}
\end{singlespace}
\caption{Language modification}
\label{tab:miniprlglangmod}
\end{code-list}

\section{Unification}

\subsection{Current unification}
Listing~\ref{tab:miniprlgunif}
\begin{code-list}[H]
\begin{singlespace}
  \inputminted[linenos, firstline=65, lastline=82]{haskell}{haskell-proto3-pentyl-skater.hs}
\end{singlespace}
\caption{Current unification procedure in \cite{website:mini-prolog-hugs98}}
\label{tab:miniprlgunif}
\end{code-list}

\subsection{Monadic unification}
Listing~\ref{tab:miniprlgmonadicunif}
\begin{code-list}[H]
\begin{singlespace}
  \inputminted[linenos, firstline=1, lastline=41]{haskell}{haskell-proto3-bevy-icebox.hs}
\end{singlespace}
\caption{Monadic unification}
\label{tab:miniprlgmonadicunif}
\end{code-list}



\section{Chapter recapitulation}
Recapitulating, this chapter provided us with a working implementation of a \progLang{Prolog}-like interpreter with the option to change
the search strategy further proving the modularity and genericity of the language modification and monadic unification procedure.

\end{document}
