\documentclass[thesis-solanki.tex]{files}


\begin{document}

\chapter{Prototype 3}{\label{proto3}}


\section{What is this chapter about}

-----------------------------------------------------------------------------

When two terms are to be unified we can use \ref{proto1} ,

term1 and term2 are matched and an assignment is the result 

now this may be a part of a query resolution procedure

to reach the point where two terms need to unified will happen through some sort of search strategy

and our approach is independent of that, and this prototype is a proof of concept to implementing query resolution using unification with
variable search strategy


\section{Unification}
The first, \yyy{"}{``}unification,\yyy{"}{''} regards how terms are matched and variables assigned to make terms match. \cite{website:prologunification}



\section{Resolution}
this where the complete procedure takes place after the query is passed along with the knowledge 

the resolver searches to create and a list of  goals and then tries to achieve each one.

\cite{website:prologresolution}

\cite{website:resolutionlogicwiki}




\section{Search strategies}
The base implementation used for this prototype  is \cite{website:mini-prolog-hugs98} and below are the search strategies 
\section{Stack Engine}
\begin{minted}[linenos]{haskell}
-- Stack based Prolog inference engine
-- Mark P. Jones November 1990, modified for Gofer 20th July 1991,
-- and for Hugs 1.3 June 1996.
--
-- Suitable for use with Hugs 98.
--

module StackEngine( version, prove ) where

import Prolog
import st
import Interact

version = "stack based"

--- Calculation of solutions:

-- the stack based engine maintains a stack of triples (s,goal,alts)
-- corresponding to backtrack points, where s is the stitution at that
-- point, goal is the outstanding goal and alts is a list of possible ways
-- of extending the current proof to find a solution.  Each member of alts
-- is a pair (tp,u) where tp is a new goal that must be proved and u is
-- a unifying stitution that must be combined with the stitution s.
--
-- the list of relevant clauses at each step in the execution is produced
-- by attempting to unify the head of the current goal with a suitably
-- renamed clause from the database.

type Stack = [ (st, [Term], [Alt]) ]
type Alt   = ([Term], st)

alts       :: Database -> Int -> Term -> [Alt]
alts db n g = [ (tp,u) | (tm:-tp) <- renClauses db n g, u <- unify g tm ]
      
-- The use of a stack enables backtracking to be described explicitly,
-- in the following `state-based' definition of prove:

prove      :: Database -> [Term] -> [st]
prove db gl = solve 1 nullst gl []
 where
   solve :: Int -> st -> [Term] -> Stack -> [st]
   solve n s []     ow          = s : backtrack n ow
   solve n s (g:gs) ow
                    | g==theCut = solve n s gs (cut ow)
                    | otherwise = choose n s gs (alts db n (app s g)) ow

   choose :: Int -> st -> [Term] -> [Alt] -> Stack -> [st]
   choose n s gs []          ow = backtrack n ow
   choose n s gs ((tp,u):rs) ow = solve (n+1) (u@@s) (tp++gs) ((s,gs,rs):ow)

   backtrack                   :: Int -> Stack -> [st]
   backtrack n []               = []
   backtrack n ((s,gs,rs):ow)   = choose (n-1) s gs rs ow


--- Special definitions for the cut predicate:

theCut    :: Term
theCut     = Struct "!" []

cut                  :: Stack -> Stack
cut ss                = []

--- End of Engine.hs
\end{minted}


\section{Pure Engine}
\begin{minted}[linenos]{haskell}
-- The Pure Prolog inference engine (using explicit prooftrees)
-- Mark P. Jones November 1990, modified for Gofer 20th July 1991,
-- and for Hugs 1.3 June 1996.
--
-- Suitable for use with Hugs 98.
--

module PureEngine( version, prove ) where

import Prolog
import st
import Interact
import Data.List(nub)

version = "tree based" 

--- Calculation of solutions:

-- Each node in a prooftree corresponds to:
-- either: a solution to the current goal, represented by Done s, where s
--         is the required stitution
-- or:     a choice between a number of trees ts, each corresponding to a
--         proof of a goal of the current goal, represented by Choice ts.
--         The proof tree corresponding to an unsolvable goal is Choice [] 

data Prooftree = Done st  |  Choice [Prooftree]

-- prooftree uses the rules of Prolog to construct a suitable proof tree for
--           a specified goal
prooftree   :: Database -> Int -> st -> [Term] -> Prooftree
prooftree db = pt
 where pt           :: Int -> st -> [Term] -> Prooftree
       pt n s []     = Done s 													-- Rule 1
       pt n s (g:gs) = Choice [ pt (n+1) (u@@s) (map (app u) (tp++gs))
                              | (tm:-tp)<-renClauses db n g, u<-unify g tm ]	-- Rule 2
{--
pt 1 nullst [] = Done (nullst)

pt n s (g:gs)

renClauses :- Rename variables in a clause, the parameters are the database, an int (X_1 will become X_2 if 2 is passed) and a goal term 
			(head of list) resulting in a clause.

unify :- take the head of the list and and match with head of clause from renClauses to get a list of stitutions.

app :- function for applying (st) to (Terms)
the new list is formed by replacing the cluase head with its body and applying the unifier to get a new list of terms

so the new parameters for pt are

(n+1) (the old stitution + the new one from unify) (the list formed after applying the unifier to the (body of head goal + rest of the list)) 


Working of a small example

The database,
(foldl addClause emptyDb [((:-) (Struct "hello" []) []), ((:-) (Struct "hello" [Struct "world" []]) []), ((:-) (Struct "hello" []) [Struct "world" []]), ((:-) (Struct "hello" [Var (1,"X")]) [])])
hello.
hello(world).
hello:-world.
hello(X_1).

The other parameters are 1 nullst(as mentioned in the prove function).

For the list of goals, [(Struct "hello" []), (Struct "hello" [(Struct "world" [])]), (Struct "hello" [Var (0, "X")])]

1. [Struct "hello" []] :: [Term]

* Rule 1 does not apply

* Rule 2 does apply,

(tm:- tp) <- renClauses db 1 (Struct "hello" [])

tm ==> "hello , hello(world) , hello , hello(X_1) , "
tp ==> "[] , [] , [world] , [] , "









--}



-- DFS Function
-- search performs a depth-first search of a proof tree, producing the list
-- of solution stitutions as they are encountered.
search              :: Prooftree -> [st] 
search (Done s)      = [s]
search (Choice pts)  = [ s | pt <- pts, s <- search pt ]


prove    :: Database -> [Term] -> [st]
prove db  = search . prooftree db 1 nullst

--- End of PureEngine.hs
\end{minted}

\section{Andorra Engine}
\begin{minted}[linenos]{haskell}
{-
By Donald A. Smith, December 22, 1994, based on Mark Jones' PureEngine.

This inference engine implements a variation of the Andorra Principle for
logic programming. (See references at the end of this file.) The basic
idea is that instead of always selecting the first goal in the current
list of goals, select a relatively deterministic goal.

For each goal g in the list of goals, calculate the resolvents that would
result from selecting g.  Then choose a g which results in the lowest
number of resolvents.  If some g results in 0 resolvents then fail.
(This would occur for a goal like:  ?- append(A,B,[1,2,3]),equals(1,2).)
Prolog would not perform this optimization and would instead search
and backtrack wastefully.  If some g results in a single resolvent
(i.e., only a single clause matches) then that g will get selected;
by selecting and resolving g, bindings are propagated sooner, and useless
search can be avoided, since these bindings may prune away choices for
other clauses.  For example: ?- append(A,B,[1,2,3]),B=[].
-}

module AndorraEngine( version, prove ) where

import Prolog
import st
import Interact

version = "Andorra Principle Interpreter (select deterministic goals first)"

solve   :: Database -> Int -> st -> [Term] -> [st]
solve db = slv where
   slv           :: Int -> st -> [Term] -> [st]
   slv n s [] = [s]
   slv n s goals =
    let allResolvents = resolve_selecting_each_goal goals db n in
      let (gs,gres) =  findMostDeterministic allResolvents in
          concat [slv (n+1) (u@@s) (map (app u) (tp++gs)) | (u,tp) <- gres]

resolve_selecting_each_goal::
    [Term] -> Database -> Int -> [([Term],[(st,[Term])])]
--  For each pair in the list that we return, the first element of the
--  pair is the list of unresolved goals; the second element is the list
--  of resolvents of the selected goal, where a resolvent is a pair
--  consisting of a stitution and a list of new goals.
resolve_selecting_each_goal goals db n = [(gs, gResolvents) |
      (g,gs) <- delete goals, let gResolvents = resolve db g n]

-- The unselected goals from above are not passed in.
resolve :: Database -> Term -> Int -> [(st,[Term])]
resolve db g n = [(u,tp) | (tm:-tp)<-renClauses db n g, u<-unify g tm]
-- u is not yet applied to tp, since it is possible that g won't be selected.
-- Note that unify could be nondeterministic.

findMostDeterministic:: [([Term],[(st,[Term])])] -> ([Term],[(st,[Term])])
findMostDeterministic  allResolvents = minF comp allResolvents where
   comp:: (a,[b]) -> (a,[b]) -> Bool
   comp (_,gs1) (_,gs2) = (length gs1) < (length gs2)
-- It seems to me that there is an opportunity for a clever compiler to
-- optimize this code a lot. In particular, there should be no need to
-- determine the total length of a goal list if it is known that
-- there is a shorter goal list in allResolvents ... ?

delete ::  [a] -> [(a,[a])]
delete l = d l [] where
   d :: [a] -> [a] ->  [(a,[a])]
   d [g] sofar = [ (g,sofar) ]
   d (g:gs) sofar = (g,sofar++gs) : (d gs (g:sofar))

minF               :: (a -> a -> Bool) -> [a] -> a
minF f (h:t) = m h t where
--   m :: a -> [a] -> a
     m sofar [] = sofar
     m sofar (h:t) = if (f h sofar) then m h t else m sofar t

prove    :: Database -> [Term] -> [st]
prove db  = solve db 1 nullst

{- An optimized, incremental version of the above interpreter would use
  a data representation in which for each goal in "goals" we carry around
  the list of resolvents.  After each resolution step we update the lists.
-}

{- References

   Seif Haridi & Per Brand, "Andorra Prolog, an integration of Prolog
   and committed choice languages" in Proceedings of FGCS 1988, ICOT,
   Tokyo, 1988.

   Vitor Santos Costa, David H. D. Warren, and Rong Yang, "Two papers on
   the Andorra-I engine and preprocessor", in Proceedings of the 8th
   ICLP. MIT Press, 1991.

   Steve Gregory and Rong Yang, "Parallel Constraint Solving in
   Andorra-I", in Proceedings of FGCS'92. ICOT, Tokyo, 1992.

   Sverker Janson and Seif Haridi, "Programming Paradigms of the Andorra
   Kernel Language", in Proceedings of ILPS'91. MIT Press, 1991.

   Torkel Franzen, Seif Haridi, and Sverker Janson, "An Overview of the
   Andorra Kernel Language", In LNAI (LNCS) 596, Springer-Verlag, 1992.
-}
\end{minted}

\section{Current Unification}
\begin{minted}[linenos]{haskell}
{-# LANGUAGE  DeriveDataTypeable,
              ViewPatterns,
              ScopedTypeVariables,
              DefaultSignatures,
              TypeOperators,
              TypeFamilies,
              DataKinds,
              DataKinds,
              PolyKinds,
              OverlappingInstances,
              TypeOperators,
              LiberalTypeSynonyms,
              TemplateHaskell,
              AllowAmbiguousTypes,
              ConstraintKinds, 
              Rank2Types, 
              MultiParamTypeClasses,
              FunctionalDependencies,
              FlexibleContexts,
              FlexibleInstances,
              UndecidableInstances 
              #-}

-- stitutions and Unification of Prolog Terms
-- Mark P. Jones November 1990, modified for Gofer 20th July 1991,
-- and for Hugs 1.3 June 1996.
--
-- Suitable for use with Hugs 98.
--

module st where

import Prolog
import CustomSyntax
import Data.Map as Map
import Data.Maybe
import Data.Either

--Unification
import Control.Unification.IntVar
import Control.Unification.STVar as ST

import Control.Unification.Ranked.IntVar
import Control.Unification.Ranked.STVar

import Control.Unification.Types as UT

import Control.Monad.State.UnificationExtras
import Control.Unification as U

-- Monads
import Control.Monad.Error
import Control.Monad.Trans.Except

import Data.Functor.Fixedpoint as DFF

--State
import Control.Monad.State.Lazy
import Control.Monad.ST
import Control.Monad.Trans.State as Trans

infixr 3 @@
infix  4 ->-

--- stitutions:

type st = Id -> Term

newtype stP = stP { unstP :: st }

-- instance Show stP where
--  show (i) = show $ Var i
-- stitutions are represented by functions mapping identifiers to terms.
--
-- app s     extends the stitution s to a function mapping terms to terms
{--
Looks like an apply function that applies a stitution function tho the variables in a term.
--}


-- nullst is the empty stitution which maps every identifier to the same identifier (as a term).



-- i ->- t   is the stitution which maps the identifier i to the term t, but otherwise behaves like nullst.


-- s1@@ s2  is the composition of stitutions s1 and s2
--           N.B.  app is a monoid homomorphism from (st,nullst,(@@))
--           to (Term -> Term, id, (.)) in the sense that:
--                  app (s1 @@ s2) = app s1 . app s2
--                 s @@ nullst = s = nullst @@ s

app                     :: st -> Term -> Term
app s (Var i)            = s i
app s (Struct a ts)      = Struct a (Prelude.map (app s) ts)
{--
app (stFunction) (Struct "hello" [Var (0, "Var")])
hello(Var_2) :: Term

--}


nullst               :: st
nullst i              = Var i
{--
nullst (0, "Var")
Var :: Term
--}


--
(->-)                   :: Id -> Term -> st
(i ->- t) j | j==i       = t
            | otherwise  = Var j
{--
:t (->-) (1,"X") (Struct "hello" [])
(1,"X") ->- Struct "hello" [] :: (Int,[Char]) -> Term
--}


-- Function composition for applying two stitution functions.
(@@)                    :: st -> st -> st
s1 @@ s2                 = app s1 . s2
\end{minted}


\section{Syntax Modification}
\begin{minted}[linenos]{haskell}
{-# LANGUAGE  DeriveDataTypeable, 
              ViewPatterns, 
              ScopedTypeVariables, 
              FlexibleInstances, 
              DefaultSignatures,
              TypeOperators,
              FlexibleContexts,
              TypeFamilies,
              DataKinds,
              OverlappingInstances,
              DataKinds,
              PolyKinds,
              TypeOperators,
              LiberalTypeSynonyms,
              TemplateHaskell,
              RankNTypes,
              AllowAmbiguousTypes,
              MultiParamTypeClasses, 
              FunctionalDependencies,
              ConstraintKinds,
              ExistentialQuantification 
              #-}

module CustomSyntax where

import Data.Generics (Data(..), Typeable(..))
import Data.List (intercalate)
import Data.Char (isLetter)

import Control.Monad.State.UnificationExtras
import Control.Unification as U


import Data.Functor.Fixedpoint as DFF


import Control.Unification.IntVar
import Control.Unification.STVar as ST

import Control.Unification.Ranked.IntVar
import Control.Unification.Ranked.STVar

import Control.Unification.Types as UT



import Data.Traversable as T 
import Data.Functor 
import Data.Foldable
import Control.Applicative


import Data.List.Extras.Pair
import Data.Map as Map
import Data.Set as S


import Control.Monad.Error
import Control.Monad.Trans.Except


import Prolog

data FTS a = forall a . FV Id | FS Atom [a] deriving (Eq, Show, Ord, Typeable)

newtype Prolog = P (Fix FTS) deriving (Eq, Show, Ord, Typeable)

unP :: Prolog -> Fix FTS
unP (P x) = x 

instance Functor FTS where
	fmap = T.fmapDefault

instance Foldable FTS where
 	foldMap = T.foldMapDefault  

instance Traversable FTS where
	traverse f (FS atom xs) = FS atom <$> sequenceA (Prelude.map f xs)
	traverse _ (FV v) =	pure (FV v)

instance Unifiable FTS where
	zipMatch (FS al ls) (FS ar rs) = if (al == ar) && (length ls == length rs)
      				then FS al <$> pairWith (\l r -> Right (l,r)) ls rs
      				else Nothing
	zipMatch (FV v1) (FV v2) = if (v1 == v2) then Just (FV v1) 
		else Nothing
	zipMatch _ _ = Nothing

instance Applicative FTS where
	pure x = FS "" [x]
	(FS a fs) <*> (FS b xs)   = FS (a ++ b) [f x | f <- fs, x <- xs]
	--other cases
{--
instance Monad FTS where
	func = 
instance Variable FTS where
	func = 

instance BindingMonad FTS where
	func = 
--}

data VariableName = VariableName Int String

idToVariableName :: Id -> VariableName
idToVariableName (i, s) = VariableName i s

variablenameToId :: VariableName -> Id
variablenameToId (VariableName i s) = (i,s)

termFlattener :: Term -> Fix FTS
termFlattener (Var v)           =   DFF.Fix $ FV v
termFlattener (Struct a xs)     =   DFF.Fix $ FS a (Prelude.map termFlattener xs)

unFlatten :: Fix FTS -> Term
unFlatten (DFF.Fix (FV v))      =   Var v
unFlatten (DFF.Fix (FS a xs))   =   Struct a (Prelude.map unFlatten xs)


variableExtractor :: Fix FTS -> [Fix FTS]
variableExtractor (Fix x) = case x of
  (FS _ xs)   ->  Prelude.concat $ Prelude.map variableExtractor xs
  (FV v)     ->  [Fix $ FV v]
--  _       ->  [] 

variableIdExtractor :: Fix FTS -> [Id]
variableIdExtractor (Fix x) = case x of
	(FS _ xs) -> Prelude.concat $ Prelude.map variableIdExtractor xs
	(FV v) -> [v]

{--
variableNameExtractor :: Fix FTS -> [VariableName]
variableNameExtractor (Fix x) = case x of
  (FS _ xs) -> Prelude.concat $ Prelude.map variableNameExtractor xs
  (FV v)     -> [v]
  _         -> [] 
--}

variableSet :: [Fix FTS] -> S.Set (Fix FTS)
variableSet a = S.fromList a

variableNameSet :: [Id] -> S.Set (Id)
variableNameSet a = S.fromList a


varsToDictM :: (Ord a, Unifiable t) =>
    S.Set a -> ST.STBinding s (Map a (ST.STVar s t))
varsToDictM set = foldrM addElt Map.empty set where
  addElt sv dict = do
    iv <- freeVar
    return $! Map.insert sv iv dict


uTermify 
  :: Map Id (ST.STVar s (FTS)) 
  -> UTerm FTS (ST.STVar s (FTS)) 
  -> UTerm FTS (ST.STVar s (FTS))
uTermify varMap ux = case ux of
  UT.UVar _             -> ux
  UT.UTerm (FV v)       -> maybe (error "bad map") UT.UVar $ Map.lookup v varMap
 -- UT.UTerm t            -> UT.UTerm $! fmap (uTermify varMap) t
  UT.UTerm (FS a xs)    -> UT.UTerm $ FS a $! fmap (uTermify varMap) xs   


translateToUTerm ::
    Fix FTS -> ST.STBinding s
            (UT.UTerm (FTS) (ST.STVar s (FTS)),
             Map Id (ST.STVar s (FTS)))
translateToUTerm e1Term = do
  let vs = variableNameSet $ variableIdExtractor e1Term
  varMap <- varsToDictM vs
  let t2 = uTermify varMap . unfreeze $ e1Term
  return (t2,varMap)


-- | vTermify recursively converts @UVar x@ into @UTerm (VarA x).
-- This is a routine of @ translateFromUTerm @.  The resulting
-- term has no (UVar x) terms.

vTermify :: Map Int Id ->
            UT.UTerm (FTS) (ST.STVar s (FTS)) ->
            UT.UTerm (FTS) (ST.STVar s (FTS))
vTermify dict t1 = case t1 of
  UT.UVar x  -> maybe (error "logic") (UT.UTerm . FV) $ Map.lookup (UT.getVarID x) dict
  UT.UTerm r ->
    case r of
      FV iv   -> t1
      _       -> UT.UTerm . fmap (vTermify dict) $ r

translateFromUTerm :: 
    Map Id (ST.STVar s (FTS)) ->
    UT.UTerm (FTS) (ST.STVar s (FTS)) -> Prolog
translateFromUTerm dict uTerm =
  P .  maybe (error "Logic") id . freeze . vTermify varIdDict $ uTerm where
    forKV dict initial fn = Map.foldlWithKey' (\a k v -> fn k v a) initial dict
    varIdDict = forKV dict Map.empty $ \ k v -> Map.insert (UT.getVarID v) k


-- | Unify two (E1 a) terms resulting in maybe a dictionary
-- of variable bindings (to terms).
--
-- NB !!!!
-- The current interface assumes that the variables in t1 and t2 are
-- disjoint.  This is likely a mistake that needs fixing

unifyTerms :: Fix FTS -> Fix FTS -> Maybe (Map Id (Prolog))
unifyTerms t1 t2 = ST.runSTBinding $ do
  answer <- runExceptT $ unifyTermsX t1 t2
  return $! either (const Nothing) Just answer

-- | Unify two (E1 a) terms resulting in maybe a dictionary
-- of variable bindings (to terms).
--
-- This routine works in the unification monad

unifyTermsX ::
    Fix FTS -> Fix FTS ->
    ExceptT  (UT.UFailure (FTS) (ST.STVar s (FTS)))
        (ST.STBinding s)
        (Map Id (Prolog))
unifyTermsX t1 t2 = do
    (x1,d1) <- lift . translateToUTerm $ t1
    (x2,d2) <- lift . translateToUTerm $ t2
    _ <- unify x1 x2
    makeDicts $ (d1,d2)



mapWithKeyM :: (Ord k,Applicative m,Monad m)
               => (k -> a -> m b) -> Map k a -> m (Map k b)
mapWithKeyM = Map.traverseWithKey


makeDict :: 
            Map Id (ST.STVar s (FTS)) -> ST.STBinding s (Map Id (Prolog))
makeDict sVarDict =
    flip mapWithKeyM sVarDict $ \ _ -> \ iKey -> do
        Just xx <- UT.lookupVar $ iKey
        return $! (translateFromUTerm sVarDict) xx


-- | recover the bindings for the variables of the two terms
-- unified from the monad.

makeDicts :: 
    (Map Id (ST.STVar s (FTS)), Map Id (ST.STVar s (FTS))) ->
    ExceptT  (UT.UFailure (FTS) (ST.STVar s (FTS)))
    (ST.STBinding s) (Map Id (Prolog))
makeDicts (svDict1, svDict2) = do
  let svDict3 = (svDict1 `Map.union` svDict2)
  let ivs = Prelude.map UT.UVar . Map.elems $ svDict3
  applyBindingsAll ivs
  -- the interface below is dangerous because Map.union is left-biased.
  -- variables that are duplicated across terms may have different
  -- bindings because `translateToUTerm` is run separately on each
  -- term.
  lift . makeDict $ svDict3

instance (UT.Variable v, Functor t) => Error (UT.UFailure t v) where {}

test1 ::
  ErrorT (UT.UFailure (FTS) (ST.STVar s (FTS)))
           (ST.STBinding s)
            (UT.UTerm (FTS) (ST.STVar s (FTS)),
             Map Id (ST.STVar s (FTS)))
test1 = do
    let
        t1a = (Fix $ FV $ (0, "x"))
        t2a = (Fix $ FV $ (1, "y"))
    (x1,d1) <- lift . translateToUTerm $ t1a --error
    (x2,d2) <- lift . translateToUTerm $ t2a
    x3 <- U.unify x1 x2
    return (x3, d1 `Map.union` d2)


test2 ::
  ErrorT (UT.UFailure (FTS) (ST.STVar s (FTS)))
           (ST.STBinding s)
            (UT.UTerm (FTS) (ST.STVar s (FTS)),
             Map Id (ST.STVar s (FTS)))
test2 = do
    let
        t1a = (Fix $ FS "a" [Fix $ FV $ (0, "x")])
        t2a = (Fix $ FV $ (1, "y"))
    (x1,d1) <- lift . translateToUTerm $ t1a --error
    (x2,d2) <- lift . translateToUTerm $ t2a
    x3 <- U.unify x1 x2
    return (x3, d1 `Map.union` d2)


test3 ::
  ErrorT (UT.UFailure (FTS) (ST.STVar s (FTS)))
           (ST.STBinding s)
            (UT.UTerm (FTS) (ST.STVar s (FTS)),
             Map Id (ST.STVar s (FTS)))
test3 = do
    let
        t1a = (Fix $ FS "a" [Fix $ FV $ (0, "x")])
        t2a = (Fix $ FV $ (0, "x"))
    (x1,d1) <- lift . translateToUTerm $ t1a --error
    (x2,d2) <- lift . translateToUTerm $ t2a
    x3 <- U.unify x1 x2
    return (x3, d1 `Map.union` d2)
{--
goTest test3
"ok:    STVar -9223372036854775807 
[(VariableName 0 \"x\",STVar -9223372036854775808)]"
--}

test4 ::
  ErrorT (UT.UFailure (FTS) (ST.STVar s (FTS)))
           (ST.STBinding s)
            (UT.UTerm (FTS) (ST.STVar s (FTS)),
             Map Id (ST.STVar s (FTS)))
test4 = do
    let
        t1a = (Fix $ FS "a" [Fix $ FV $ (0, "x")])
        t2a = (Fix $ FV $ (0, "x"))
    (x1,d1) <- lift . translateToUTerm $ t1a --error
    (x2,d2) <- lift . translateToUTerm $ t2a
    x3 <- U.unifyOccurs x1 x2
    return (x3, d1 `Map.union` d2)
{--
goTest test4
"ok:    STVar -9223372036854775807 
[(VariableName 0 \"x\",STVar -9223372036854775808)]"
--}

test5 ::
  ErrorT (UT.UFailure (FTS) (ST.STVar s (FTS)))
           (ST.STBinding s)
            (UT.UTerm (FTS) (ST.STVar s (FTS)),
             Map Id (ST.STVar s (FTS)))
test5 = do
    let
        t1a = (Fix $ FS "a" [Fix $ FV $ (0, "x")])
        t2a = (Fix $ FS "b" [Fix $ FV $ (0, "y")])
    (x1,d1) <- lift . translateToUTerm $ t1a --error
    (x2,d2) <- lift . translateToUTerm $ t2a
    x3 <- U.unify x1 x2
    return (x3, d1 `Map.union` d2)

goTest :: (Show b) => (forall s . 
  (ErrorT (UT.UFailure (FTS) (ST.STVar s (FTS)))
           (ST.STBinding s)
            (UT.UTerm (FTS) (ST.STVar s (FTS)),
             Map Id (ST.STVar s (FTS))))) -> String
goTest test = ST.runSTBinding $ do
  answer <- runErrorT $ test
  return $! case answer of
    (Left x)  -> "error: " ++ show x
    (Right y) -> "ok:    " ++ show y


---------------------------------------------------------------
---------------------------------------------------------------
---------------GLUE-CODE---------------------------------------
{--
monadicUnify :: Term -> Term -> ErrorT (UT.UFailure (FTS) (ST.STVar s (FTS)))
           (ST.STBinding s)
            (UT.UTerm (FTS) (ST.STVar s (FTS)),
             Map Id (ST.STVar s (FTS)))
monadicUnify t1 t2 = do
	let	
		t1f = termFlattener t1
		t2f = termFlattener t2
	(x1,d1) <- lift . translateToUTerm $ t1f
	(x2,d2) <- lift . translateToUTerm $ t2f
	x3 <- U.unify x1 x2
	return (x3, d1 `Map.union` d2)

--}

-- type st = Id -> Term

-- Convert result from monadicUnify to [st]
{--
goMonadicTest :: (Show b) => (forall s . 
  (ErrorT (UT.UFailure (FTS) (ST.STVar s (FTS)))
           (ST.STBinding s)
            (UT.UTerm (FTS) (ST.STVar s (FTS)),
             Map Id (ST.STVar s (FTS))))) -> [st]
goMonadicTest test = ST.runSTBinding $ do
  answer <- runErrorT $ test
  return $! case answer of
    (Left x)  -> [nullst]
    (Right y) -> convertTost y
--}

--(Id, STVar s FTS)
--convertTost :: Map Id (ST.STVar s FTS) -> [(Id, ST.STVar s FTS)]
{--
convertTost m = convertTost1 Map.toAscList m

convertTost1 (id, ST.STVar _ fts):xs = (id, (unFlatten fts)) : convertTost1 xs
--}
\end{minted}

\section{Monadic Unification}
\begin{minted}[linenos]{haskell}
monadicUnification :: (BindingMonad FTS (STVar s FTS) (ST.STBinding s)) => (forall s. (Term -> Term -> ErrorT (UT.UFailure (FTS) (ST.STVar s (FTS)))
           (ST.STBinding s) (UT.UTerm (FTS) (ST.STVar s (FTS)),
            Map Id (ST.STVar s (FTS)))))
monadicUnification t1 t2 = do
  let
    t1f = termFlattener t1
    t2f = termFlattener t2
  (x1,d1) <- lift . translateToUTerm $ t1f
  (x2,d2) <- lift . translateToUTerm $ t2f
  x3 <- U.unify x1 x2
  --get state from somehwere, state -> dict
  return $! (x3, d1 `Map.union` d2)


goUnify ::
  (forall s. (BindingMonad FTS (STVar s FTS) (ST.STBinding s))
  =>
      (ErrorT
          (UT.UFailure FTS (ST.STVar s FTS))
          (ST.STBinding s)
          (UT.UTerm FTS (ST.STVar s FTS),
             Map Id (ST.STVar s FTS)))
     )
  -> [(Id, Prolog)]
goUnify test = ST.runSTBinding $ do
  answer <- runErrorT $ test --ERROR
  case answer of
    (Left _)            -> return []
    (Right (_, dict))   -> f1 dict


f1 ::
  (BindingMonad FTS (STVar s FTS) (ST.STBinding s))
  => (forall s. Map Id (STVar s FTS)
      -> (ST.STBinding s [(Id, Prolog)])
     )
f1 dict = do
  let ld1 = Map.toList dict
  ld2 <- sequence [ v1 | (k,v) <- ld1, let v1 = UT.lookupVar v]
  let ld3 = [ (k,v) | ((k,_),Just v) <- ld1 `zip` ld2]
      ld4 = [ (k,v) | (k,v2) <- ld3, let v = translateFromUTerm dict v2 ]
  return ld4


--unify :: Term -> Term -> [st]
unify t1 t2 = stConvertor (goUnify (monadicUnification t1 t2))


varX :: Term
varX = Var (0,"x")

varY :: Term
varY = Var (1,"y")


stConvertor :: [(Id, Prolog)] -> [st]
stConvertor xs = Prelude.map (\(varId, p) -> (->-) varId (unFlatten $ unP $ p)) xs 
\end{minted}


\section{Chapter Recap}


\end{document}
