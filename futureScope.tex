\documentclass[thesis-solanki.tex]{subfiles}



\ifMain
\externaldocument{thesis-solanki}
\fi
\begin{document}

%----------------------------------------------------------------------------
\chapter{Future Scope}\label{chap:futureScope}


\section{About this chapter}
This chapter discusses additions that could be made on the contributions of this thesis.


\section{\progLang{Prolog} quasiquoter}
With the current eDSL, the native \progLang{Haskell} constructs are used to write a \progLang{Prolog}-like program. The syntax though
\progLang{Haskell} in nature differs considerably from \progLang{Prolog}. A quasiquoter could be a step closer to the solution for writing
native \progLang{Prolog}-like programs in \progLang{Haskell}. Listing ~ \ref{tab:qqprlginhskll} shows an example for the same.

\begin{code-list}[H]
\begin{minted}{haskell}
[prolog|a(X) :- b(y)|]
\end{minted}
\caption{A sample quasi quoted expression for \progLang{Prolog} in \progLang{Haskell}}
\label{tab:qqprlginhskll}
\end{code-list}

This not only provides a simpler interface but also allows interchangeable usage of programming constructs of different languages in the 
same expression.For the example above, \prologConstruct{X} is a  \progLang{Prolog} variable and \haskellConstruct{y} is a 
\progLang{Haskell} variable injected into the expression 

\section{Runtime search strategy selection}
The \progLang{Prolog} interpreter in Chapter~\ref{proto3} can work with multiple search strategies. The search must be provided at compile
time and hence one must make an estimated guess to the nature of the problem to select the most appropriate choice. A possible solution
to this problem could be the addition of providing and/or switching the search strategy at runtime. 
Listing~\ref{tab:queryresolvervariablesearchstrat} depicts an example query request.

\begin{code-list}[H]
\begin{minted}{haskell}
queryResolver searcStrategy query knowledgeBase
\end{minted}
\caption{Query resolver with variable search strategy}
\label{tab:queryresolvervariablesearchstrat}
\end{code-list}  

\section{Database operations for \progLang{Prolog}}
Operations for manipulating the clause database containing facts and clauses are provided with many \progLang{Prolog} distributions such as
\progLang{SWI Prolog} \cite{website:swiprologdbops}. Operations such \prologConstruct{assertz} \cite{website:assertzswiprolog} would provide
the ability to modify the knowledge base at runtime. 

Moreover, \progLang{SWI Prolog} provides multiple mechanisms for storage and modification as described in \cite{website:swiprologdbops}.

\section{Multi type variable language}
The eDSl \haskellConstruct{FlatTerm} has a single type variable i.e.,

\mint{haskell}|FlatTerm a|

This restricts the constructors (generated terms) to all be of the same type or no type. An eDSL with multiple type variables will provide
its constructors with multiple options resulting in multitype terms generated by the grammar. Listing~\ref{tab:multitypevariableedsl} shows 
an example.

\begin{code-list}[H]
\begin{minted}[linenos]{haskell}
data FlatTerm a b 
	= Constructor_1 a
	| Constrcutor_2 b
	| ...
\end{minted}
\caption{Multi type variable eDSL}
\label{tab:multitypevariableedsl}
\end{code-list}

\section{Constructor specific unification(quantifier + logic) for the same DSL}
Continuing the example from the previous section, with multi typed constructors one can have constructor specific unification. Generally 
speaking, quantifiers and logic can be programmed per constructor adding to the extensibility of the language.   

\section{Pure + IO Language Combined}
Chapter~\ref{proto4} defines a grammar for encapsulating and ultimately controlling impure actions in a language. The constructors are split
into two types representing pure and impure actions. A program would be a chaining/ sequence of these actions. The possibility of a 
constructor having a pure and an impure component would be possible if the language has multiple type variables. 
Listing~\ref{tab:hybridconstruct} provides an example.


\begin{code-list}[H]
\begin{minted}[linenos]{haskell}
data ResultWithIO typevariableforpureexpressions typevariableforioexpressions
	= PureConstructor_1 ....
	| PureConstructor_2 ....
	| IOContrcutor_1 .....
	| IOContructor_2 ...
	| ContructorWithBoth_1 .....
	| ContructorWithBoth_2 .....
	deriving(........)
\end{minted}
\caption{Grammar with hybrid constructors}
\label{tab:hybridconstruct}
\end{code-list}



\section{Chapter recapitulation}
Recapitulating, this chapter provided us with points where this thesis could be extended in the future along with suitable samples for the
respective implementations.


\ifMain
\begin{scope}
  \nolinenumbers
  \enotesize
  \par
  \begin{singlespace}
  \setlength{\parskip}{12pt plus 2pt minus 1pt}
  \theendnotes
  \par
  \end{singlespace}
\end{scope}
\unbcbibliography{bibliography}
\fi
\end{document}
