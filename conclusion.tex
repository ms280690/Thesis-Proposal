\documentclass[thesis-solanki.tex]{subfiles}


\ifMain
\externaldocument{thesis-solanki}
\fi
\begin{document}

% ---------------------------------------------------------------------------
\chapter{Conclusion}\label{chap:conclusion}
% ---------------------------------------------------------------------------
\paragraph{}
This thesis set out to explore the various approaches used for bringing features of multiple languages into a single 
programming environment, and has identified embedding and paradigm integration as being the major ones. This study has also sought to improve
the existing work on implementing \progLang{Prolog} in \progLang{Haskell}. One contribution of this thesis is a  
\progLang{Prolog}-like language in \progLang{Haskell} which not only is closer to a ``real'' \progLang{Prolog} distribution but also provides 
logic programming functionality as natively as possible in the host language.

During this process we have also thrown light on the subject of eDSLs in \progLang{Haskell} and the support for the same. Moreover, we
have provided a methodology for replicating results achieved in this thesis.

\progLang{Haskell} has been shown to be an effective tool for embedding DSLs. If used correctly \progLang{Haskell}'s lazy nature can be utilized to calculate results lazily; as in returning only a single result from all
the possible ones. Opening up the language enables us to take advantage of the existing classes such as \haskellClass{Functor, Applicative, Monad, Foldable, Traversable}. Adding a type variable not only allows us to 
inject custom functionality into the language but permits jumping between the different grammars since they are isomorphic. It is fairly straight forward to embed a recursive untyped grammar into a typed language 
such as \progLang{Haskell} by defining a data type with multiple constructors. Monads provide the functionality to define custom control flow mechanisms along with encapsulation of impure side effecting 
computations. Moreover, due to the nature of monads, a approach similar to \chapterReference{proto4}{Prototype 4} can not only be possible but also generalized, i.e., the separation of interpreting different types
of code such as pure or impure.

\begin{comment}
	We gained some insights into merging declarative languages:
\begin{enumerate}
\item using \progLang{Haskell}'s lazy nature to calculate results lazily (we get one result and then we hit `;' and then the next and so on).

\item Opening up the language  allows easy domain switching (Term $\leftrightarrow$ FlatTerm) because they are isomorphic.

\item Easy extension (Fix FlatTerm).

\item Easily add quantifiers and logic

\item type system allows for safer programs and earlier detection of errors.

\item Custom control flow with the use of monads

\item encapsulate impure code in a monad
\end{enumerate}

We gained some insights into multi paradigm languages:
\begin{itemize}
	\item
\end{itemize}
\end{comment}

\ifMain
\begin{scope}
  \nolinenumbers
  \enotesize
  \par
  \begin{singlespace}
  \setlength{\parskip}{12pt plus 2pt minus 1pt}
  \theendnotes
  \par
  \end{singlespace}
\end{scope}
\unbcbibliography{bibliography}
\fi

\end{document}
