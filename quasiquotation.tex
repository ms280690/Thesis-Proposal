\documentclass[thesis-solanki.tex]{subfiles}


\ifMain
\externaldocument{thesis-solanki}
\fi
\begin{document}



% ---------------------------------------------------------------------------
\chapter{Quasiquotation}\label{chap:quasiquotation}

\section{What this chapter is about}

\noindent\rule{\textwidth}{0.5pt}
%-----------------------------------------------------------------------------

\section{What is Quasiquotation ?}
\begin{enumerate}
\item \cite{website:quotationstanford}

When language is used to attribute properties to language or otherwise theorize about it, a linguistic device is needed that â€˜turns\eref{non-ascii} 
language on itself'. 
Quotation is one such device. It is our primary meta-linguistic tool.

\item \cite{website:quasiquotationfreedictionary}

a metalinguistic device for referring to the form of an expression containing variables without referring to the symbols for those 
variables. Thus while ``not p'' refers to the expression consisting of the word not followed by the letter p, the quasi-quotation \newline
$\ulcorner$ not p $\urcorner$ refers to the form of any expression consisting of the word not followed by any value of the variable p.

\item  Quasiquotation Wikipedia, \cite{wikiquasi}

Quasi-quotation or Quine quotation is a linguistic device in formal languages that facilitates rigorous and terse formulation of general rules about linguistic expressions while properly observing the use--mention distinction.

\cite{website:usementiondistinctionwiki}
The use--mention distinction is a foundational concept of analytic philosophy,[1] according to which it is necessary to make a distinction 
between using a word (or phrase) and mentioning it


\end{enumerate}

\section{Quasiquotaion in \progLang{Haskell}}
\cite{haskellquasi, mainland2007s} 

Quasiquoting allows programmers to use custom, domain-specific syntax to construct fragments of their program. Along with 
\progLang{Haskell}'s existing support for domain specific languages, you are now free to use new syntactic forms for your EDSLs. 

Working with complex data types can impose a significant syntactic burden; extensive applications of nested data constructors are often 
required to build values of a given data type, or, worse yet, to pattern match against values.

Allow \progLang{Haskell} expressions and patterns to be constructed using domain specific, programmer-defined concrete syntax.


\section{Chapter Recapitulation}

\ifMain
\begin{scope}
  \nolinenumbers
  \enotesize
  \par
  \begin{singlespace}
  \setlength{\parskip}{12pt plus 2pt minus 1pt}
  \theendnotes
  \par
  \end{singlespace}
\end{scope}
\unbcbibliography{bibliography}
\fi

\end{document}
