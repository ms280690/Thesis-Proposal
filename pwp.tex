\documentclass[thesis-solanki.tex]{subfiles}



\ifMain
\externaldocument{thesis-solanki}
\fi
\begin{document}

% ---------------------------------------------------------------------------
\chapter{\progLang{Prolog}}\label{chap:pwp}
% ---------------------------------------------------------------------------
%Prolog / Why Prolog ?


\section{About this chapter}

This chapter discusses the properties of the target language \progLang{Prolog} and the feature set that will be translated to the host 
language to extend its capabilities.

\section{Logic programming language}

%Our base language, \progLang{Haskell}, is from the same paradigm. It would be interesting to see how two languages of the same family with 
%conflicting features can be made to work together.

One of the reasons is that both \progLang{Haskell}, the base language and \progLang{Prolog}, the target language are from the same paradigm.
This provides a platform to play around with the conflicting characteristics of the two languages.

\section{\progLang{Prolog}}
\progLang{Prolog} is a general purpose logic programming language mainly used in artificial intelligence and
  computational linguistics.
  It is a declarative language, i.e., a program is a set of facts an rules running a
  query on which will return a result.
  The relation between them is defined by clauses using \textit{Horn Clauses} \cite{wikiprolog}.
  \progLang{Prolog} is very popular and has a number of implementations
  \cite{website:comparisonofprologimplementationswiki} for different purposes.

\subsection{Simple Syntax}

\progLang{Prolog} is dynamically typed. It has a single data type, the term, which has several subtypes: atoms, numbers, variables and 
compound terms \cite{wikiprolog}.


An atom is a general-purpose name with no inherent meaning. It is composed of a sequence of characters that is parsed by the 
\progLang{Prolog} reader as a single unit.

Numbers can be floats or integers. Many \progLang{Prolog} implementations also provide unbounded integers and rational numbers.

Variables are denoted by a string consisting of letters, numbers and underscore characters, and beginning with an upper-case letter or 
underscore. Variables closely resemble variables in logic in that they are placeholders for arbitrary terms. A variable can become 
instantiated (bound to equal a specific term) via unification.

A compound term is composed of an atom called a ``functor'' and a number of ``arguments'', which are again terms. Compound terms are 
ordinarily written as a functor followed by a comma-separated list of argument terms, which is contained in parentheses. The number of 
arguments is called the term's arity. An atom can be regarded as a compound term with arity zero.


A \progLang{Prolog} program is a description of relations, defined by the use of clauses. Pure \progLang{Prolog} is restricted to Horn 
clauses, a Turing-complete subset of first-order predicate logic. The clauses can be one of two types: facts and rules 
\cite{website:prologintroumiami}.

\begin{comment}
In \progLang{Prolog}
 all data objects are called terms.\endnote{%
   Fix.
}
 Atomic terms
 come in two forms: atoms and integers.
 Atoms (this is a misnomer,\endnote{%
   Fix
}
 as in logic predicates are called atoms, and atoms are called constants. However, we'll stick to the 
 \progLang{Prolog}\endnote{%
   Fix.
}
 convention.)
consist of
strings of alphanumerics and ``\texttt{\_}'', starting with a lower case alphabetic.
Strings enclosed in 'single quotes'\endnote{%
  What?
}
Integers are numeric.
Example
\par
\begin{minted}[linenos]{prolog}
geoff
'the cat and the rat'
'ABCD'
123
\end{minted}
\end{comment}

\begin{comment}
\subsection{Function terms}

Functions have the form \Verb!<functor>(<term>{,<term>})!
where \Verb!functor! starts with a lower-case alphabetic. 
\paragraph{Example}
\par
\begin{minted}[linenos]{prolog}
prerequisite_to(adv_ai)
grade_attained_in(prerequisite_to(adv_ai),pass)
\end{minted}
     
The number of arguments is the arity of the function. When referring to a functor, it is written with its arity in
the format \Verb!<functor>/<arity>!. This is also true for atoms, whose arity is 0.
Note that this is a recursive definition.
\paragraph{The view of functions as trees}
\subparagraph{Operators}
Some functors are used in infix notation, e.g., \Verb!5+4!.
Operators do not cause the associated function to be carried out.
\subparagraph{Variables}

Uppercase or `\Verb!_!' start variables.
\paragraph{Example}
\begin{minted}[linenos]{prolog}
Who
What
_special
_
\end{minted}
     
Variables in \progLang{Prolog} are rather different from those in most other languages. Further discussion and use is deferred until later.

\end{comment}

\subsection{Simple Semantics}

Since the commutative nature of logical disjunction and conjunction, declaratively speaking the order of rules and their sub goals is
irrelevant. However, the procedural aspect must be taken into account to determine the execution strategy of \progLang{Prolog} since it
has to deal with impure predicates. Moreover, a particular order of execution can lead to infinite recursion.


\subsection{Constraint handling rules}
\textbf{semantics of chr in \progLang{swi Prolog}} 
In this subsection the operational semantics of CHR\endnote{%
  What is CHR?
}\elabel{CHR-query}
in Prolog are presented informally. They do not differ essentially from other CHR\eref{CHR-query} systems.
When a constraint\endnote{%
  In this context, what is a constraint?
}
is called, it is considered an active constraint and the system will try to apply the rules to it. Rules are tried and executed sequentially in the order they are written.




A rule is conceptually tried for an active constraint in the following way.
The active constraint is matched with a constraint in the head of the rule.
If more constraints appear in the head, they are looked for among the suspended constraints, which are called
passive constraints in this context.
If the necessary passive constraints can be found and all match with the head of the rule and the guard of the rule
succeeds, then the rule is committed and the body of the rule executed.
If not all the necessary passive constraints can be found, or the matching or the guard fails, then the body is not
executed and the process of trying and executing simply continues with the following rules.
If for a rule there are multiple constraints in the head, the active constraint will try the rule sequentially
multiple times, each time trying to match with another constraint \cite{website:swiprologsyntaxandsemantics}.

This process ends either when the active constraint disappears, i.e., it is removed by some rule, or
after the last rule has been processed.
In the latter case the active constraint becomes suspended.

A suspended constraint is eligible as a passive constraint for an active constraint.
The other way it may interact again with the rules is when a variable appearing in the constraint becomes bound to
either a non-variable or another variable involved in one or more constraints.
In that case the constraint is triggered, i.e.,
it becomes an active constraint and all the rules are tried.
\begin{description}

\item [Rule Types]
  There are three different kinds of rules, each with its specific semantics:
\begin{enumerate}

\item simplification
The simplification rule removes the constraints in its head and calls its body.

\item propagation
The propagation rule calls its body exactly once for the constraints in its head.

\item simpagation
The simpagation rule removes the constraints in its head after the \ and then calls its body. It is an optimization of simplification rules 
of the form: [constraints\_1, constraints\_2 $<=>$ constraints\_1, body ] Namely, in the simpagation form: [ constraints\_1 
$\backslash$constraints\_2 $<=>$ body ] The constraints\_1 constraints are not called in the body.

\end{enumerate}


\item [Rule Names] Naming a rule is optional and has no semantic meaning. It only functions as documentation for the programmer.

\item [Pragmas] The semantics of the pragmas are:

  \begin{itemize}
  \item \Verb!passive(Identifier)!
    The constraint in the head of a rule \unknownLabel{Identifier}\endnote{%
      Choose an appropriate semantic tag for this word unless it is intended to have its ordinary English meaning.
}\elabel{text-kind}
    can only match a passive constraint in that rule.  
  \end{itemize}
\end{description}

\subsection{Universal Horn clauses}


\subsection{Unification}



\subsection{Definite clause grammar}



\section{Embedding \progLang{Prolog}}

\begin{comment}
Existing implementations

As a starting point a few publications and implementations helped in exploring the topic. The shortcomings were clearly visible to work and
improve upon giving a starting point.
\end{comment}

\progLang{Prolog} seems to be a very popular choice as a target language. Also for the specific topic of embedding \progLang{Prolog} in 
\progLang{Haskell}, implementations and publications exist which provide a starting point.\endnote{%
  The surrounding \macroName{begin}\macroArg{enumerate} should be a
  \texttt{description} environment, or a list of
  \macroName{sub}\textsuperscript{\textasteriskcentered}\texttt{section}'s.
	\mehul{changed}
}


\section{Chapter recapitulation}
Recapitulating, this chapter provided information on \progLang{Prolog} as a logic programming language.

\ifMain
\begin{scope}
  \nolinenumbers
  \enotesize
  \par
  \begin{singlespace}
  \setlength{\parskip}{12pt plus 2pt minus 1pt}
  \theendnotes
  \par
  \end{singlespace}
\end{scope}
\unbcbibliography{bibliography}
\fi

\end{document}
