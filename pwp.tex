\documentclass[thesis-solanki.tex]{subfiles}



\ifMain
\externaldocument{thesis-solanki}
\fi
\begin{document}

% ---------------------------------------------------------------------------
\chapter{\progLang{Prolog}}\label{chap:pwp}
% ---------------------------------------------------------------------------
%Prolog / Why Prolog ?


\section{About this chapter}

This chapter discusses the properties of the target language \progLang{Prolog} and the feature set that will be translated to the host 
language to extend its capabilities.

\section{Logic programming language}

%Our base language, \progLang{Haskell}, is from the same paradigm. It would be interesting to see how two languages of the same family with 
%conflicting features can be made to work together.

One of the reasons is that both \progLang{Haskell}, the base language and \progLang{Prolog}, the target language are from the same paradigm.
This provides a platform to play around with the conflicting characteristics of the two languages.

\section{\progLang{Prolog}}
\progLang{Prolog} is a general purpose logic programming language mainly used in artificial intelligence and
  computational linguistics.
  It is a declarative language, i.e., a program is a set of facts an rules running a
  query on which will return a result.
  The relation between them is defined by clauses using \textit{Horn Clauses} \cite{wikiprolog}.
  \progLang{Prolog} is very popular and has a number of implementations
  \cite{website:comparisonofprologimplementationswiki} for different purposes.

\subsection{Simple Syntax}

\progLang{Prolog} is dynamically typed. It has a single data type, the term, which has several subtypes: atoms, numbers, variables and 
compound terms \cite{wikiprolog}.


An atom is a general-purpose name with no inherent meaning. It is composed of a sequence of characters that is parsed by the 
\progLang{Prolog} reader as a single unit.

Numbers can be floats or integers. Many \progLang{Prolog} implementations also provide unbounded integers and rational numbers.

Variables are denoted by a string consisting of letters, numbers and underscore characters, and beginning with an upper-case letter or 
underscore. Variables closely resemble variables in logic in that they are placeholders for arbitrary terms. A variable can become 
instantiated (bound to equal a specific term) via unification.

A compound term is composed of an atom called a ``functor'' and a number of ``arguments'', which are again terms. Compound terms are 
ordinarily written as a functor followed by a comma-separated list of argument terms, which is contained in parentheses. The number of 
arguments is called the term's arity. An atom can be regarded as a compound term with arity zero.


A \progLang{Prolog} program is a description of relations, defined by the use of clauses. Pure \progLang{Prolog} is restricted to Horn 
clauses, a Turing-complete subset of first-order predicate logic. The clauses can be one of two types: facts and rules 
\cite{website:prologintroumiami}.

\begin{comment}
In \progLang{Prolog}
 all data objects are called terms.\endnote{%
   Fix.
}
 Atomic terms
 come in two forms: atoms and integers.
 Atoms (this is a misnomer,\endnote{%
   Fix
}
 as in logic predicates are called atoms, and atoms are called constants. However, we'll stick to the 
 \progLang{Prolog}\endnote{%
   Fix.
}
 convention.)
consist of
strings of alphanumerics and ``\texttt{\_}'', starting with a lower case alphabetic.
Strings enclosed in 'single quotes'\endnote{%
  What?
}
Integers are numeric.
Example
\par
\begin{minted}[linenos]{prolog}
geoff
'the cat and the rat'
'ABCD'
123
\end{minted}
\end{comment}

\begin{comment}
\subsection{Function terms}

Functions have the form \Verb!<functor>(<term>{,<term>})!
where \Verb!functor! starts with a lower-case alphabetic. 
\paragraph{Example}
\par
\begin{minted}[linenos]{prolog}
prerequisite_to(adv_ai)
grade_attained_in(prerequisite_to(adv_ai),pass)
\end{minted}
     
The number of arguments is the arity of the function. When referring to a functor, it is written with its arity in
the format \Verb!<functor>/<arity>!. This is also true for atoms, whose arity is 0.
Note that this is a recursive definition.
\paragraph{The view of functions as trees}
\subparagraph{Operators}
Some functors are used in infix notation, e.g., \Verb!5+4!.
Operators do not cause the associated function to be carried out.
\subparagraph{Variables}

Uppercase or `\Verb!_!' start variables.
\paragraph{Example}
\begin{minted}[linenos]{prolog}
Who
What
_special
_
\end{minted}
     
Variables in \progLang{Prolog} are rather different from those in most other languages. Further discussion and use is deferred until later.

\end{comment}

\subsection{Simple Semantics}

Since the commutative nature of logical disjunction and conjunction, declaratively speaking the order of rules and their sub goals is
irrelevant. However, the procedural aspect must be taken into account to determine the execution strategy of \progLang{Prolog} since it
has to deal with impure predicates. Moreover, a particular order of execution can lead to infinite recursion.

\subsection{Universal Horn clauses}


\subsection{Unification}



\subsection{Definite clause grammar}



\section{Embedding \progLang{Prolog}}

\begin{comment}
Existing implementations

As a starting point a few publications and implementations helped in exploring the topic. The shortcomings were clearly visible to work and
improve upon giving a starting point.
\end{comment}

\progLang{Prolog} seems to be a very popular choice as a target language. Also for the specific topic of embedding \progLang{Prolog} in 
\progLang{Haskell}, implementations and publications exist which provide a starting point.\endnote{%
  The surrounding \macroName{begin}\macroArg{enumerate} should be a
  \texttt{description} environment, or a list of
  \macroName{sub}\textsuperscript{\textasteriskcentered}\texttt{section}'s.
	\mehul{changed}
}


\section{Chapter recapitulation}
Recapitulating, this chapter provided information on \progLang{Prolog} as a logic programming language.

\ifMain
\begin{scope}
  \nolinenumbers
  \enotesize
  \par
  \begin{singlespace}
  \setlength{\parskip}{12pt plus 2pt minus 1pt}
  \theendnotes
  \par
  \end{singlespace}
\end{scope}
\unbcbibliography{bibliography}
\fi

\end{document}
