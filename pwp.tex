\documentclass[proposal.tex]{subfiles} 



\begin{document}

% ---------------------------------------------------------------------------
\section{Prolog or Why Prolog ?}\label{sect:pwp}
% ---------------------------------------------------------------------------



Prolog / Why Prolog ?
\begin{enumerate}
\item \progLang{Prolog} as a logic programming language.

http://eliminatingwork.blogspot.ca/2010/02/why-prolog-is-by-far-best-most.html 


First of all I will only advocate the use of pure prolog - that means no recursion, lists, forall's, and any other features. Extra features that were added destroy the whole point of the elegance of prolog.

A prolog equivalent is pervasively used everywhere right under everyone's nose - sql. Pure prolog is almost exactly the same as relational database sql, except that sql has a much worse syntax and requires declaring column names. Column names are a necessary thing for sql's use case (use by many programmers/dba's over the years), but there is no excuse for the sql syntax (attempts were made in the past to get relational databbases to get prolog syntax in the form of datalog but to no avail).

Business rules engines used in many "enterprise" application servers are also shoddy versions of prolog (when they're backward chaining. Forward chaining is inferior to backward chaining, which implies that all these rules engines should be embedded prolog's if the implementors had bothered to study up history).

Sparql is also prolog, except that you can only have facts (predicates) with three arguments.

Disregard procedural and object oriented languages - there's plenty of other blogs/essays/textbooks/papers that tell why those are wrong. Some good exlanations are in Paul Graham's and Peter Norvig's writings (google it - why lisp, dynamic languages, on lisp, paradigms of ai).

So the question is, why is prolog better than functional languages lisp,haskell,ml,ruby etc.

Here's why, in order of increasing importance

1) The syntax is incredibly simple (like lisp), and incredibly elegant (unlike lisp and any other language).
(
)
.
:-
,
"
!
;
fail
repeat
write
read
assert
retract
those are all the researved characters/words you need (if you're working in pure prolog which I'm advocating)

I won't bother explaining it here for newbie's - the following is a good start

A prolog introduction for hackers
http://www.kuro5hin.org/story/2004/2/25/124713/784

2) You don't need to know recursion, lambda's, closures, folds, monads, side effects, pattern matching, map/reduce's, flatten, cyclic this and that, blah blah blah rocket science.
You don't even need to know data structures - forget linked lists,arrays,trees,graphs
In fact, forget algorithms.
If you're working in prolog the entirety of computer science is irrelevant 
(for programming in domains other than computer science itself of course. If you're implementing machine learning/computer vision /database systems/operating systems you would have to know computer science - but you could more elagantly do those tasks in prolog than other languages as well).

3) Prolog programs can usually be translated to/from readable english with a simple regular expression
s/(/ is /g
s/)././g
s/:-/ implies /g
s/,/ and /g
s/;/ or /g
s/fail/try the next choice/g
s/!/abandon this line of reasoning/g
s/[capital letter X]/[unknown X]/g (I can't be bothered to figure out how to do this in regex, if it's possible at all)

You could even write your program in a spreadsheet, export as csv, and convert to prolog with equally simple as above regexp (and the reverse prolog->spreadsheet).

What this means is that most/all of your program can be written by a nonprogrammer (similar to how cobol and sql were intended, except that it has a better chance of working this time because the greater inherent simplicity of the syntax).

4) When you program in prolog, you're almost always just creating a description of the world in small "orthogonal" chunks without any concious effort to do so. In functional programming there are builtin "orthogonals", like map/filter etc, but most of the time you have to work very hard to make sure you're writing elegant concise code.

Good functional programmers keep refactoring their code sitting in their repl. Prolog programs just seem to pour out in a concise form that is the only way it can be written. If this seems miraculous - just imagine that you're actually writing sql code.
There is only one obvious way to write a sql query (forget performance concerns - you're not managing millions of rows of data as you are in an actual sql database).
In sql all you're ever writing is queries and views. In prolog all you're ever writing is queries (views are just queries in prolog).

Sql programmers don't think about code refactoring - there's only one way to do it, and it's the most concise way as well, and orthogonal to all other sql code. As do prolog programmers.

\begin{minted}{prolog}
conclusion :- prolog_rules.
prolog_rules :- write("Prolog is by far the best, most productive, easiest programming language ever").
\end{minted}



\item Why embed \progLang{Prolog} ?



\end{enumerate}

\end{document}