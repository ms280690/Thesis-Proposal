\documentclass[thesis-solanki.tex]{subfiles}



\begin{document}

% ---------------------------------------------------------------------------
\chapter{Prolog or Why Prolog ?}\label{chap:pwp}
% ---------------------------------------------------------------------------
%Prolog / Why Prolog ?


\section{What is this chapter about}

-----------------------------------------------------------------------------

This chapter discusses the properties of the target language \progLang{Prolog} and the feature set that will be translated to the host 
language to extend its capabilities.

\begin{enumerate}
\item Why a Logic Programming Language ?

\item \progLang{Prolog} as a logic programming language.

\progLang{Prolog} is a general purpose logic programming language mainly used in artificial intelligence and computational linguistics.  
It is a Declarative language i.e. a program is a set of facts an rules running a query on which will return a result. The relation
between them is defined by clauses using \textit{Horn Clauses}\cite{wikiprolog}. \progLang{Prolog} is very popular and has a number of 
implementations \cite{website:comparisonofprologimplementationswiki} for different purposes. 

\item Why embed \progLang{Prolog} ?

\begin{enumerate}


\item Existing Implementations

As a starting point a few publications and implementations helped in exploring the topic. The shortcomings were clearly visible to work and
improve upon giving a starting point.

\item Simple Syntax
\cite{wikiprolog}

Prolog is dynamically typed. It has a single data type, the term, which has several subtypes: atoms, numbers, variables and compound terms.

An atom is a general-purpose name with no inherent meaning. It is composed of a sequence of characters that is parsed by the Prolog reader 
as a single unit.

Numbers can be floats or integers. Many Prolog implementations also provide unbounded integers and rational numbers.

Variables are denoted by a string consisting of letters, numbers and underscore characters, and beginning with an upper-case letter or 
underscore. Variables closely resemble variables in logic in that they are placeholders for arbitrary terms. A variable can become 
instantiated (bound to equal a specific term) via unification.

A compound term is composed of an atom called a "functor" and a number of "arguments", which are again terms. Compound terms are ordinarily 
written as a functor followed by a comma-separated list of argument terms, which is contained in parentheses. The number of arguments is 
called the term's arity. An atom can be regarded as a compound term with arity zero.

Prolog programs describe relations, defined by means of clauses. Pure Prolog is restricted to Horn clauses, a Turing-complete subset of 
first-order predicate logic. There are two types of clauses: Facts and rules.



\cite{website:prologintroumiami}
In Prolog all data objects are called terms
Atomic terms

Come in two forms, atoms and integers.
Atoms (this is a misnomer as in logic predicates are called atoms and atoms are called constants. However, we'll stick to the Prolog convention.)
Strings of alphanumerics and \_, starting with a lower case alphabetic.
Strings enclosed in 'single quotes'
Integers are numeric
Example
\begin{minted}[linenos]{prolog}
geoff
'the cat and the rat'
'ABCD'
123
\end{minted}
     
Function terms

Functions have the form <functor>(<term>{,<term>})
Functor starts with a lower case alphabetic.
Example
\begin{minted}[linenos]{prolog}
prerequisite_to(adv_ai)
grade_attained_in(prerequisite_to(adv_ai),pass)
\end{minted}
     
The number of arguments is the arity of the function. When referring to a functor, it is written with its arity in the format <functor>/<arity>. This is also true for atoms, whose arity is 0.
Note that this is a recursive definition.
The view of functions as trees
Operators
Some functors are used in infix notation, e.g. 5+4
Operators do not cause the associated function to be carried out.
Variables

Uppercase or \_ for start of variables
Example
\begin{minted}[linenos]{prolog}
Who
What
_special
_
\end{minted}
     
Variables in Prolog are rather different to those in most other languages. Further discussion and use is deferred until later.




\item Simple Semantics

Under a declarative reading, the order of rules, and of goals within rules, is irrelevant since logical disjunction and conjunction are 
commutative. Procedurally, however, it is often important to take into account Prolog's execution strategy, either for efficiency reasons, 
or due to the semantics of impure built-in predicates for which the order of evaluation matters. Also, as Prolog interpreters try to unify 
clauses in the order they're provided, failing to give a correct ordering can lead to infinite recursion.


In this subsection the operational semantics of CHR in Prolog are presented informally. They do not differ essentially from other CHR systems.
When a constraint is called, it is considered an active constraint and the system will try to apply the rules to it. Rules are tried and executed sequentially in the order they are written.

\cite{website:swiprologsyntaxandsemantics}

A rule is conceptually tried for an active constraint in the following way. The active constraint is matched with a constraint in the head of the rule. If more constraints appear in the head, they are looked for among the suspended constraints, which are called passive constraints in this context. If the necessary passive constraints can be found and all match with the head of the rule and the guard of the rule succeeds, then the rule is committed and the body of the rule executed. If not all the necessary passive constraints can be found, or the matching or the guard fails, then the body is not executed and the process of trying and executing simply continues with the following rules. If for a rule there are multiple constraints in the head, the active constraint will try the rule sequentially multiple times, each time trying to match with another constraint.

This process ends either when the active constraint disappears, i.e. it is removed by some rule, or after the last rule has been processed. In the latter case the active constraint becomes suspended.

A suspended constraint is eligible as a passive constraint for an active constraint. The other way it may interact again with the rules is when a variable appearing in the constraint becomes bound to either a non-variable or another variable involved in one or more constraints. In that case the constraint is triggered, i.e. it becomes an active constraint and all the rules are tried.
\begin{enumerate}

\item Rule Types There are three different kinds of rules, each with its specific semantics:
\begin{enumerate}

\item simplification
The simplification rule removes the constraints in its head and calls its body.

\item propagation
The propagation rule calls its body exactly once for the constraints in its head.

\item simpagation
The simpagation rule removes the constraints in its head after the \ and then calls its body. It is an optimization of simplification rules 
of the form: [constraints\_1, constraints\_2 $<=>$ constraints\_1, body ] Namely, in the simpagation form: [ constraints\_1 
$\backslash$constraints\_2 $<=>$ body ] The constraints\_1 constraints are not called in the body.

\end{enumerate}


\item Rule Names Naming a rule is optional and has no semantic meaning. It only functions as documentation for the programmer.

\item Pragmas The semantics of the pragmas are:

\item passive(Identifier)
The constraint in the head of a rule Identifier can only match a passive constraint in that rule. 

\end{enumerate}

\item Universal Horn Clauses


\item Unification

\item Definite Clause Grammar


\end{enumerate}

\begin{comment}
http://eliminatingwork.blogspot.ca/2010/02/why-prolog-is-by-far-best-most.html 


First of all I will only advocate the use of pure prolog - that means no recursion, lists, forall's, and any other features. Extra features that were added destroy the whole point of the elegance of prolog.

A prolog equivalent is pervasively used everywhere right under everyone's nose - sql. Pure prolog is almost exactly the same as relational database sql, except that sql has a much worse syntax and requires declaring column names. Column names are a necessary thing for sql's use case (use by many programmers/dba's over the years), but there is no excuse for the sql syntax (attempts were made in the past to get relational databbases to get prolog syntax in the form of datalog but to no avail).

Business rules engines used in many "enterprise" application servers are also shoddy versions of prolog (when they're backward chaining. Forward chaining is inferior to backward chaining, which implies that all these rules engines should be embedded prolog's if the implementors had bothered to study up history).

Sparql is also prolog, except that you can only have facts (predicates) with three arguments.

Disregard procedural and object oriented languages - there's plenty of other blogs/essays/textbooks/papers that tell why those are wrong. Some good exlanations are in Paul Graham's and Peter Norvig's writings (google it - why lisp, dynamic languages, on lisp, paradigms of ai).

So the question is, why is prolog better than functional languages lisp,haskell,ml,ruby etc.

Here's why, in order of increasing importance

1) The syntax is incredibly simple (like lisp), and incredibly elegant (unlike lisp and any other language).
(
)
.
:-
,
"
!
;
fail
repeat
write
read
assert
retract
those are all the researved characters/words you need (if you're working in pure prolog which I'm advocating)

I won't bother explaining it here for newbie's - the following is a good start

A prolog introduction for hackers
http://www.kuro5hin.org/story/2004/2/25/124713/784

2) You don't need to know recursion, lambda's, closures, folds, monads, side effects, pattern matching, map/reduce's, flatten, cyclic this and that, blah blah blah rocket science.
You don't even need to know data structures - forget linked lists,arrays,trees,graphs
In fact, forget algorithms.
If you're working in prolog the entirety of computer science is irrelevant 
(for programming in domains other than computer science itself of course. If you're implementing machine learning/computer vision /database systems/operating systems you would have to know computer science - but you could more elagantly do those tasks in prolog than other languages as well).

3) Prolog programs can usually be translated to/from readable english with a simple regular expression
s/(/ is /g
s/)././g
s/:-/ implies /g
s/,/ and /g
s/;/ or /g
s/fail/try the next choice/g
s/!/abandon this line of reasoning/g
s/[capital letter X]/[unknown X]/g (I can't be bothered to figure out how to do this in regex, if it's possible at all)

You could even write your program in a spreadsheet, export as csv, and convert to prolog with equally simple as above regexp (and the reverse prolog->spreadsheet).

What this means is that most/all of your program can be written by a nonprogrammer (similar to how cobol and sql were intended, except that it has a better chance of working this time because the greater inherent simplicity of the syntax).

4) When you program in prolog, you're almost always just creating a description of the world in small "orthogonal" chunks without any concious effort to do so. In functional programming there are builtin "orthogonals", like map/filter etc, but most of the time you have to work very hard to make sure you're writing elegant concise code.

Good functional programmers keep refactoring their code sitting in their repl. Prolog programs just seem to pour out in a concise form that is the only way it can be written. If this seems miraculous - just imagine that you're actually writing sql code.
There is only one obvious way to write a sql query (forget performance concerns - you're not managing millions of rows of data as you are in an actual sql database).
In sql all you're ever writing is queries and views. In prolog all you're ever writing is queries (views are just queries in prolog).

Sql programmers don't think about code refactoring - there's only one way to do it, and it's the most concise way as well, and orthogonal to all other sql code. As do prolog programmers.

\begin{minted}{prolog}
conclusion :- prolog_rules.
prolog_rules :- write("Prolog is by far the best, most productive, easiest programming language ever").
\end{minted}
\end{comment}

\end{enumerate}


\section{Chapter Recap}


\end{document}
