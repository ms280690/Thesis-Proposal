
\documentclass[thesis-solanki.tex]{subfiles}


\begin{document}
%----------------------------------------------------------------------------
\chapter{Introduction}\label{chap:introduction}
%----------------------------------------------------------------------------


\section{What is this chapter about}

This chapter introduces the scope of the thesis along with the preliminary arguments{\Huge\textcolor{red}{.}}


-----------------------------------------------------------------------------


\section{Beginnings}
\begin{comment}
Computers have become a part of everyone's life. From the ones in our pockets to the ones on desks or in our school bags, working or in fact living without 
them is difficult if not impossible. All the more reason to know how to use one. Simply speaking just using a computer these days is not enough. To be able 
to utilise their true potential, one must go deeper and communicate with them. This is where the art of programming steps in.     
\end{comment}

Programming has become an integral part of working and interacting with computers and day by day more and more complex
problems are being tackled using the power of programming technologies.
It is possibly the only way to talk to computers and hence the need for a robust and multi purpose programming language
has never been more urgent.\endnote{%
  This argument for the need for robust, multi-purpose languages seems weak.
  Can we either drop it, or extend it somewhat?
}
The desirability of a programming language depends on a lot of factors such as the ease of use, the features and
functionalities that it provides, adaptability and what sort of problems \yyy{can it}{it can} solve.
One is spoilt for choice with a number of options for a wide variety of programming paradigms, for example Object
Oriented Languages.\endnote{%
  Rewrite this sentence.
}

Over the last decade the declarative style of programming has gained popularity.
The methodologies that have stood out are the Functional and Logical Approaches.\endnote{%
  What style guide are you using to determine capitalization?
}
The former is based on Functions and Lambda Calculus, while the latter is based on Horn Clause Logic.
Each of them has its own advantages and ﬂaws.
How does one choose which approach to adopt?
Perhaps one does not need to choose!
This document looks at the attempts, improvements and future possibilities of uniting \progLang{Haskell}, a Purely
Functional Programming Language and \progLang{Prolog}, a Logical Programming Language so that one is not forced to
choose.\endnote{%
  Say more here?
  This seems like a natural place to have more high-level comments on where the thesis is going.
}



\section{Thesis Statement}

The thesis aims to provide insights into merging two declarative languages namely, \progLang{Haskell} and
\progLang{Prolog} by embedding the latter into the former and analysing the result of doing so as they have conflicting
characteristics.
The finished product will be something like a \textit{haskellised} \progLang{Prolog} which has logical programming like
capabilities.


%----------------------------------------------------------------------------
\section{Problem Statement}
%----------------------------------------------------------------------------

Over the years the development of programming languages has become more and more rapid.
Today the number of is in the thousands and counting.\endnote{%
  Reference?  How did you come up with this estimate?
}
The successors attempt to introduce new concepts and features to simplify the process of coding a solution and assist
the programmer by lessening the burden of carrying out standard tasks and procedures.
A new one tries to capture the best of the old; learn from the mistakes, add new concepts and move on; which seems to be
good enough from an evolutionary perspective.
But all is not that straight forward when shifting from one language to another.
There are costs and incompatibilities to look at.
A language might be simple to use and provide better performance than its predecessor but not always be worth the
switch.\endnote{%
  What is the key idea in this \P{}?
  I believe that you want to link this \P{} to the idea that embedded or merged languages are good, but I don't see
  where you do that.
}

\begin{comment}
\par \progLang{Prolog} has a similar story. It was born in an era where procedural programming had made everyone notice their presence. Talking about 
competition, it was against something radical; the \progLang{C} programming language. The languages \progLang{C} has influenced is off the chart and 
so is the performance. It had paved the way for structured procedural programming and had given birth to the Unix operating system. Though the 
original version of \progLang{Prolog} has given rise to a large number of different flavours but a few drawbacks remain through the bloodline and as a 
result it did become the first choice. Some basic requirements such as modules are not provided by all compilers. To make it do real world stuff, a set of 
practical features are pushed in now and then which results in the loss of the purely declarative charm. The problem is that \progLang{Prolog} is fading 
away, \cite{website:prolog-steam,website:prolog-death,website:prolog-killer}, not many people use it and most of the times when it is used, the variant 
is usually \textit{practical} \progLang{Prolog} and the area being academia. It is not used for building large programs \cite{wikiprolog,somogyi1995
logic,website:prolog1000db}. But there are a lot of good things about \progLang{Prolog} that should not die away. Moreover, \progLang{Prolog} is ideal 
for search problems. 
\end{comment}

\progLang{Prolog} is a language that has a hard time being adopted.
Born in an era where procedural languages were receiving a lot of attention, it \xxx{suﬀered}{suffered}\endnote{%
  this looks like it has been cut and paste
} from competing against another
new kid on the block: \progLang{C}.
Some of the problems were of its own making.
Basic features like modules were not provided by all compilers.
Practical features for real world problems were added in an ad hoc way resulting in the loss of its purely declarative
charm.
Some say that \progLang{Prolog} is fading away, \cite{website:prolog-steam,website:prolog-death,website:prolog-killer}.
It is apparently not used for building large programs \cite{wikiprolog,somogyi1995logic,website:prolog1000db}.
However there are a lot of good things about Prolog: it is ideal for search problems; it has a simple syntax, and a
strong underlying theory.
It is a language that should not die away.

So the question is how to have all the good qualities of \textsc{Prolog} without actually using \progLang{Prolog}?  

\yyy{Well o}{O}ne idea is to make \progLang{Prolog} an add-on to another language which is widely used and in demand.
Here the choice is \progLang{Haskell}; as both the languages are declarative they share a common background which can
help to blend the two.

Generally speaking, programming languages with a wide scope over problem domains do not provide bespoke support for
accomplishing \xxx{even} mundane tasks.
Approaching towards the solution can be complicated and tiresome, but the programming language in question acts as the
master key.\endnote{%
  The idea of this sentence is good, but the wording needs improvement.
}%

Flipping the coin to the other side\yyy{}{,} we see\xxx{,} the more specific the language is to the problem domain\yyy{}{,} the easier it
is to solve the problem.
The simple reason being that, the problem need not be moulded according to the capability  of the
language.\endnote{%
  This preceding phrase is not a sentence.
}\elabel{not-a-sentence}
For example\yyy{}{,} a problem with a naturally recursive solution cannot take advantage of tail recursion in many
imperative languages.
Many problems require the system to be mutation free, but have to deal with uncontrolled side-effects and so
on.\endnote{%
  This example isn't as clear to me as the one in the last sentence.
}\textsuperscript{,}\endnote{%
  Use ``must'' in place of ``have to'' where you can.
}%

Putting all of the above together, Domain Specific Languages are pretty good in doing what they are designed to do,
but nothing else, resulting in choosing a different language every time.
On the other hand, a general purpose language can be used for solving a wide variety of problems but \yyy{many a times,}{often}
the programmer ends up writing some code dictated by the language rather than the problem.

\par The solution, a programming language with a split personality, in our case, sometimes functional, sometimes logical and sometimes both.\eref{not-a-sentence} 
Depending upon the problem, the language shapes itself accordingly and exhibits the desired characteristics. The ideal situation is a language with a rich 
feature set and the ability to mould itself according to the problem. A language with ability to take the appropriate skill set and present it to the 
programmer, which will reduce the hassle of jumping between languages or forcibly trying to solve a problem according to a paradigm.\eref{not-a-sentence}

\par The subject in question here is \progLang{Haskell} and the split personality being \progLang{Prolog}. How far can \progLang{Haskell} be pushed to 
dawn the avatar of \progLang{Prolog}\xxx{ }?
\yyy{}{This} is the million dollar question.\endnote{%
  ``To dawn the avatar''?  This is poetic.  Did you mean ``to don''?
}

The above\endnote{%
  Say what ``the above'' is.  
} will result in a set of characteristics which are from both the declarative paradigms. 
%----------------------------------------------------------------------------------------------------------------------   
   
%The issue being discussed here is that often when a problem is to solved using a given language, it has to be moulded %according to the capability the 
%language can provide.
This can be achieved in two ways,
\begin{description}
\item [Embedding (\chapterReference{chap:embedding}{Chapter 4}):]

  This approach involves\xxx{,} translating a complete language into the host language as an extension such as a
  library \xxx{and/} or module\xxx{ }.
  The result is very shallow as all the positives as well as the negatives are brought into the host language.
  The negatives mentioned being, that languages from different paradigms usually have conflicting characteristics
  and result in inconsistent properties of the resulting embedding.
  Examples and further discussion on the same is provided in the chapters to come.

\item [Paradigm Integration (\chapterReference{chap:multiparadigm}{Chapter 5}):]

\par This approach goes much deeper as it does not involve a direct translation. An attempt is made by taking a particular characteristic of a language 
and merging it with the characteristic of the host language in order to eliminate conflicts resulting in a multi paradigm language. It is more of weaving 
the two languages into one tight package with the best of both and maybe even the worst of both.       
\end{description}


%----------------------------------------------------------------------------
%\section{Research Approach and Contributions}
%----------------------------------------------------------------------------
%



%\subsection{Contributions}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------


%----------------------------------------------------------------------------
\section{Thesis Organization}

The next chapter, \chapterReference{chap:proposedWork}{Chapter 2} provides details about the short comings of the
previous works and the road to a better future.\endnote{%
  ``Shortcomings'' is one word.
  ``the road to a better future'' is poetic, but too vague.
}
\chapterReference{chap:background}{Chapter 3}, the background talks about the programming paradigms and languages
in general and the ones in question.
Then we look at the question from different angles namely, \chapterReference{chap:embedding}{Chapter 4},  Embedding
a Programming Language into another Programming Language and  \chapterReference{chap:embedding}{Chapter 5}, Multi
Paradigm Languages (Functional Logic Languages).
Some of the indirectly related content \chapterReference{chap:relatedWork}{Chapter 6} and finishing off with the
\chapterReference{chap:conclusion}{Chapter 7}, the expected outcomes.

%\section{The Plan}	

\section{Chapter Recap\protect\yyy{}{itulation}}


\end{document}
