\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{\PYGZob{}\PYGZhy{}}
\PYG{c+cm}{By Donald A. Smith, December 22, 1994, based on Mark Jones\PYGZsq{} PureEngine.}

\PYG{c+cm}{This inference engine implements a variation of the Andorra Principle for}
\PYG{c+cm}{logic programming. (See references at the end of this file.) The basic}
\PYG{c+cm}{idea is that instead of always selecting the first goal in the current}
\PYG{c+cm}{list of goals, select a relatively deterministic goal.}

\PYG{c+cm}{For each goal g in the list of goals, calculate the resolvents that would}
\PYG{c+cm}{result from selecting g.  Then choose a g which results in the lowest}
\PYG{c+cm}{number of resolvents.  If some g results in 0 resolvents then fail.}
\PYG{c+cm}{(This would occur for a goal like:  ?\PYGZhy{} append(A,B,[1,2,3]),equals(1,2).)}
\PYG{c+cm}{Prolog would not perform this optimization and would instead search}
\PYG{c+cm}{and backtrack wastefully.  If some g results in a single resolvent}
\PYG{c+cm}{(i.e., only a single clause matches) then that g will get selected;}
\PYG{c+cm}{by selecting and resolving g, bindings are propagated sooner, and useless}
\PYG{c+cm}{search can be avoided, since these bindings may prune away choices for}
\PYG{c+cm}{other clauses.  For example: ?\PYGZhy{} append(A,B,[1,2,3]),B=[].}
\PYG{c+cm}{\PYGZhy{}\PYGZcb{}}

\PYG{k+kr}{module} \PYG{n+nn}{AndorraEngine}\PYG{p}{(} \PYG{n}{version}\PYG{p}{,} \PYG{n}{prove} \PYG{p}{)} \PYG{k+kr}{where}

\PYG{k+kr}{import} \PYG{n+nn}{Prolog}
\PYG{k+kr}{import} \PYG{n+nn}{st}
\PYG{k+kr}{import} \PYG{n+nn}{Interact}

\PYG{n+nf}{version} \PYG{o+ow}{=} \PYG{l+s}{\PYGZdq{}Andorra Principle Interpreter (select deterministic goals first)\PYGZdq{}}

\PYG{n+nf}{solve}   \PYG{o+ow}{::} \PYG{k+kt}{Database} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{k+kt}{Int} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{n}{st} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{p}{[}\PYG{k+kt}{Term}\PYG{p}{]} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{p}{[}\PYG{n}{st}\PYG{p}{]}
\PYG{n+nf}{solve} \PYG{n}{db} \PYG{o+ow}{=} \PYG{n}{slv} \PYG{k+kr}{where}
   \PYG{n}{slv}           \PYG{o+ow}{::} \PYG{k+kt}{Int} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{n}{st} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{p}{[}\PYG{k+kt}{Term}\PYG{p}{]} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{p}{[}\PYG{n}{st}\PYG{p}{]}
   \PYG{n}{slv} \PYG{n}{n} \PYG{n}{s} \PYG{k+kt}{[]} \PYG{o+ow}{=} \PYG{p}{[}\PYG{n}{s}\PYG{p}{]}
   \PYG{n}{slv} \PYG{n}{n} \PYG{n}{s} \PYG{n}{goals} \PYG{o+ow}{=}
    \PYG{k+kr}{let} \PYG{n}{allResolvents} \PYG{o+ow}{=} \PYG{n}{resolve\PYGZus{}selecting\PYGZus{}each\PYGZus{}goal} \PYG{n}{goals} \PYG{n}{db} \PYG{n}{n} \PYG{k+kr}{in}
      \PYG{k+kr}{let} \PYG{p}{(}\PYG{n}{gs}\PYG{p}{,}\PYG{n}{gres}\PYG{p}{)} \PYG{o+ow}{=}  \PYG{n}{findMostDeterministic} \PYG{n}{allResolvents} \PYG{k+kr}{in}
          \PYG{n}{concat} \PYG{p}{[}\PYG{n}{slv} \PYG{p}{(}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{(}\PYG{n}{u}\PYG{o}{@@}\PYG{n}{s}\PYG{p}{)} \PYG{p}{(}\PYG{n}{map} \PYG{p}{(}\PYG{n}{app} \PYG{n}{u}\PYG{p}{)} \PYG{p}{(}\PYG{n}{tp}\PYG{o}{++}\PYG{n}{gs}\PYG{p}{))} \PYG{o}{|} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{tp}\PYG{p}{)} \PYG{o+ow}{\PYGZlt{}\PYGZhy{}} \PYG{n}{gres}\PYG{p}{]}

\PYG{n+nf}{resolve\PYGZus{}selecting\PYGZus{}each\PYGZus{}goal}\PYG{o+ow}{::}
    \PYG{p}{[}\PYG{k+kt}{Term}\PYG{p}{]} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{k+kt}{Database} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{k+kt}{Int} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{p}{[([}\PYG{k+kt}{Term}\PYG{p}{],[(}\PYG{n}{st}\PYG{p}{,[}\PYG{k+kt}{Term}\PYG{p}{])])]}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{}  For each pair in the list that we return, the first element of the}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{}  pair is the list of unresolved goals; the second element is the list}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{}  of resolvents of the selected goal, where a resolvent is a pair}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{}  consisting of a stitution and a list of new goals.}
\PYG{n+nf}{resolve\PYGZus{}selecting\PYGZus{}each\PYGZus{}goal} \PYG{n}{goals} \PYG{n}{db} \PYG{n}{n} \PYG{o+ow}{=} \PYG{p}{[(}\PYG{n}{gs}\PYG{p}{,} \PYG{n}{gResolvents}\PYG{p}{)} \PYG{o}{|}
      \PYG{p}{(}\PYG{n}{g}\PYG{p}{,}\PYG{n}{gs}\PYG{p}{)} \PYG{o+ow}{\PYGZlt{}\PYGZhy{}} \PYG{n}{delete} \PYG{n}{goals}\PYG{p}{,} \PYG{k+kr}{let} \PYG{n}{gResolvents} \PYG{o+ow}{=} \PYG{n}{resolve} \PYG{n}{db} \PYG{n}{g} \PYG{n}{n}\PYG{p}{]}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} The unselected goals from above are not passed in.}
\PYG{n+nf}{resolve} \PYG{o+ow}{::} \PYG{k+kt}{Database} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{k+kt}{Term} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{k+kt}{Int} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{p}{[(}\PYG{n}{st}\PYG{p}{,[}\PYG{k+kt}{Term}\PYG{p}{])]}
\PYG{n+nf}{resolve} \PYG{n}{db} \PYG{n}{g} \PYG{n}{n} \PYG{o+ow}{=} \PYG{p}{[(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{tp}\PYG{p}{)} \PYG{o}{|} \PYG{p}{(}\PYG{n}{tm}\PYG{k+kt}{:\PYGZhy{}}\PYG{n}{tp}\PYG{p}{)}\PYG{o+ow}{\PYGZlt{}\PYGZhy{}}\PYG{n}{renClauses} \PYG{n}{db} \PYG{n}{n} \PYG{n}{g}\PYG{p}{,} \PYG{n}{u}\PYG{o+ow}{\PYGZlt{}\PYGZhy{}}\PYG{n}{unify} \PYG{n}{g} \PYG{n}{tm}\PYG{p}{]}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} u is not yet applied to tp, since it is possible that g won\PYGZsq{}t be selected.}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Note that unify could be nondeterministic.}

\PYG{n+nf}{findMostDeterministic}\PYG{o+ow}{::} \PYG{p}{[([}\PYG{k+kt}{Term}\PYG{p}{],[(}\PYG{n}{st}\PYG{p}{,[}\PYG{k+kt}{Term}\PYG{p}{])])]} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{p}{([}\PYG{k+kt}{Term}\PYG{p}{],[(}\PYG{n}{st}\PYG{p}{,[}\PYG{k+kt}{Term}\PYG{p}{])])}
\PYG{n+nf}{findMostDeterministic}  \PYG{n}{allResolvents} \PYG{o+ow}{=} \PYG{n}{minF} \PYG{n}{comp} \PYG{n}{allResolvents} \PYG{k+kr}{where}
   \PYG{n}{comp}\PYG{o+ow}{::} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,[}\PYG{n}{b}\PYG{p}{])} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,[}\PYG{n}{b}\PYG{p}{])} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{k+kt}{Bool}
   \PYG{n}{comp} \PYG{p}{(}\PYG{k+kr}{\PYGZus{}}\PYG{p}{,}\PYG{n}{gs1}\PYG{p}{)} \PYG{p}{(}\PYG{k+kr}{\PYGZus{}}\PYG{p}{,}\PYG{n}{gs2}\PYG{p}{)} \PYG{o+ow}{=} \PYG{p}{(}\PYG{n}{length} \PYG{n}{gs1}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{length} \PYG{n}{gs2}\PYG{p}{)}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} It seems to me that there is an opportunity for a clever compiler to}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} optimize this code a lot. In particular, there should be no need to}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} determine the total length of a goal list if it is known that}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} there is a shorter goal list in allResolvents ... ?}

\PYG{n+nf}{delete} \PYG{o+ow}{::}  \PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{p}{[(}\PYG{n}{a}\PYG{p}{,[}\PYG{n}{a}\PYG{p}{])]}
\PYG{n+nf}{delete} \PYG{n}{l} \PYG{o+ow}{=} \PYG{n}{d} \PYG{n}{l} \PYG{k+kt}{[]} \PYG{k+kr}{where}
   \PYG{n}{d} \PYG{o+ow}{::} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}}  \PYG{p}{[(}\PYG{n}{a}\PYG{p}{,[}\PYG{n}{a}\PYG{p}{])]}
   \PYG{n}{d} \PYG{p}{[}\PYG{n}{g}\PYG{p}{]} \PYG{n}{sofar} \PYG{o+ow}{=} \PYG{p}{[} \PYG{p}{(}\PYG{n}{g}\PYG{p}{,}\PYG{n}{sofar}\PYG{p}{)} \PYG{p}{]}
   \PYG{n}{d} \PYG{p}{(}\PYG{n}{g}\PYG{k+kt}{:}\PYG{n}{gs}\PYG{p}{)} \PYG{n}{sofar} \PYG{o+ow}{=} \PYG{p}{(}\PYG{n}{g}\PYG{p}{,}\PYG{n}{sofar}\PYG{o}{++}\PYG{n}{gs}\PYG{p}{)} \PYG{k+kt}{:} \PYG{p}{(}\PYG{n}{d} \PYG{n}{gs} \PYG{p}{(}\PYG{n}{g}\PYG{k+kt}{:}\PYG{n}{sofar}\PYG{p}{))}

\PYG{n+nf}{minF}               \PYG{o+ow}{::} \PYG{p}{(}\PYG{n}{a} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{n}{a} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{k+kt}{Bool}\PYG{p}{)} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{n}{a}
\PYG{n+nf}{minF} \PYG{n}{f} \PYG{p}{(}\PYG{n}{h}\PYG{k+kt}{:}\PYG{n}{t}\PYG{p}{)} \PYG{o+ow}{=} \PYG{n}{m} \PYG{n}{h} \PYG{n}{t} \PYG{k+kr}{where}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{}   m :: a \PYGZhy{}\PYGZgt{} [a] \PYGZhy{}\PYGZgt{} a}
     \PYG{n}{m} \PYG{n}{sofar} \PYG{k+kt}{[]} \PYG{o+ow}{=} \PYG{n}{sofar}
     \PYG{n}{m} \PYG{n}{sofar} \PYG{p}{(}\PYG{n}{h}\PYG{k+kt}{:}\PYG{n}{t}\PYG{p}{)} \PYG{o+ow}{=} \PYG{k+kr}{if} \PYG{p}{(}\PYG{n}{f} \PYG{n}{h} \PYG{n}{sofar}\PYG{p}{)} \PYG{k+kr}{then} \PYG{n}{m} \PYG{n}{h} \PYG{n}{t} \PYG{k+kr}{else} \PYG{n}{m} \PYG{n}{sofar} \PYG{n}{t}

\PYG{n+nf}{prove}    \PYG{o+ow}{::} \PYG{k+kt}{Database} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{p}{[}\PYG{k+kt}{Term}\PYG{p}{]} \PYG{o+ow}{\PYGZhy{}\PYGZgt{}} \PYG{p}{[}\PYG{n}{st}\PYG{p}{]}
\PYG{n+nf}{prove} \PYG{n}{db}  \PYG{o+ow}{=} \PYG{n}{solve} \PYG{n}{db} \PYG{l+m+mi}{1} \PYG{n}{nullst}

\PYG{c+cm}{\PYGZob{}\PYGZhy{} An optimized, incremental version of the above interpreter would use}
\PYG{c+cm}{  a data representation in which for each goal in \PYGZdq{}goals\PYGZdq{} we carry around}
\PYG{c+cm}{  the list of resolvents.  After each resolution step we update the lists.}
\PYG{c+cm}{\PYGZhy{}\PYGZcb{}}

\PYG{c+cm}{\PYGZob{}\PYGZhy{} References}

\PYG{c+cm}{   Seif Haridi \PYGZam{} Per Brand, \PYGZdq{}Andorra Prolog, an integration of Prolog}
\PYG{c+cm}{   and committed choice languages\PYGZdq{} in Proceedings of FGCS 1988, ICOT,}
\PYG{c+cm}{   Tokyo, 1988.}

\PYG{c+cm}{   Vitor Santos Costa, David H. D. Warren, and Rong Yang, \PYGZdq{}Two papers on}
\PYG{c+cm}{   the Andorra\PYGZhy{}I engine and preprocessor\PYGZdq{}, in Proceedings of the 8th}
\PYG{c+cm}{   ICLP. MIT Press, 1991.}

\PYG{c+cm}{   Steve Gregory and Rong Yang, \PYGZdq{}Parallel Constraint Solving in}
\PYG{c+cm}{   Andorra\PYGZhy{}I\PYGZdq{}, in Proceedings of FGCS\PYGZsq{}92. ICOT, Tokyo, 1992.}

\PYG{c+cm}{   Sverker Janson and Seif Haridi, \PYGZdq{}Programming Paradigms of the Andorra}
\PYG{c+cm}{   Kernel Language\PYGZdq{}, in Proceedings of ILPS\PYGZsq{}91. MIT Press, 1991.}

\PYG{c+cm}{   Torkel Franzen, Seif Haridi, and Sverker Janson, \PYGZdq{}An Overview of the}
\PYG{c+cm}{   Andorra Kernel Language\PYGZdq{}, In LNAI (LNCS) 596, Springer\PYGZhy{}Verlag, 1992.}
\PYG{c+cm}{\PYGZhy{}\PYGZcb{}}
\end{Verbatim}
