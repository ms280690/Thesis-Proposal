\documentclass[thesis-solanki.tex]{subfiles}


\ifMain
\externaldocument{thesis-solanki}
\fi
\begin{document}

%-----------------------------------------------------------------------------
\chapter{Other Contributions}\label{chap:accomplishedWork}
%-----------------------------------------------------------------------------

\section{About this chapter}\label{sec:what-this-chapter:accomplishedWork}
This chapter provides the details for the conceptual contributions of this thesis along with information on the implementation of each 
prototype. Moreover, we state the other 'soft'

\mehul{surveys, making libraries work etc etc} 

contributions of this thesis.

\section{Possible directions for \progLang{Prolog} in \progLang{Haskell}}\label{sec:work-in-points}

This thesis provides a literature review on embedded domain specific languages in Chapter~\ref{chap:embedding} and a survey on
multi paradigm declarative languages in Chapter~\ref{chap:multiparadigm}. The current chapter and Chapter~\ref{chap:proposedWork} evaluate 
and assess the current work for embedding \progLang{Prolog} in \progLang{Haskell}. 

This thesis also provides an environment for 
multiple \progLang{Haskell} libraries which provide parts of \progLang{Prolog}-like functionality. 


\section{The prototypes}\label{sec:advances:accomplishedWork}
A large part of this thesis consists of prototypes of a \progLang{Prolog}-like language in \progLang{Haskell}. The conceptual advances of 
these prototypes are:
\begin{enumerate}
\item provide a modular methodology to functorize a recursive abstract grammar used to define a language,

\item modular monadic unification to leverage imperative unification algorithms,

\item integrate the procedures mentioned above into a working \prologConstruct{Prolog} implementation,

\item support for variable search strategies,

\item approach for embedding IO in eDSL.

\end{enumerate}

The details of these prototypes follows.

\subsection{Prototype 1}

Most languages have a recursive abstract syntax which restricts the embedded, domain-specific language
  \enparen{eDSL, see p.~\pageref{sec:DSL-def}}\endnote{%  
    See Note~\eref{eDSL1}, then remove this.
    \mehul{addressed note 2}
}
  in terms of its capability to \textit{open up} the language, i.e, to include meta syntactic
  variables, custom quantifiers and logic.
  (\chapterReference{proto1}{Prototype 1}) provides a methodology to convert a language whose recursive abstract
  syntax is represented by a tree into a non-recursive version whose fixed point is isomorphically equivalent to
  the original type.
  One of the outcomes is a producing a polymorphically typed embedded language within \progLang{Haskell}.

  To test it out we adopt the closed \progLang{Prolog}-like language defined in \cite{prolog-lib} and open it up.
  As for the unification part we use \cite{unification-fd-lib}, which provides a generic unification algorithm
  implementation encapsulated into a monad.


\subsection{Prototype 2}

  (\chapterReference{proto2}{Prototype 2}) does the what a \progLang{Prolog} query resolver would do given a
  query and a knowledge base.
  The mechanism for the same is adopted from \cite{prolog-lib}.
  The embedded language is modified as per the procedure in (\chapterReference{proto1}{Prototype 1}) and the
  monadic unification part is plugged into the existing architecture to demonstrate that it is independent of the
  other components.
  Lastly the result is converted into the original language via a translate function.

\subsection{Prototype 3}

  (\chapterReference{proto3}{Prototype 3}) demonstrates the modularity of the unification process of the query
  resolver with multiple search strategies.

\subsection{Prototype 4}

  (\chapterReference{proto4}{Prototype 4}) throws light on how IO operations can be embedded into the abstract
  syntax of a DSL which when interpreted would produce output consisting of a pure set of instructions irrespective
  of the nature of the construct.
  The effects are produced only when the actions are executed.

\begin{comment}
\section{Thesis Improved Contributions}\label{sec:thes-impr-contr}

\begin{enumerate}
\item Prototype 1 does
flattening language
opening up the language (binding monad)
adding custom variables
monadic unification (stuff happens in a bubble)
rec type $\rightarrow$ non rec type $\rightarrow$ fix non rec type isomorphically == rec type

You can make an Flatterm int

but you cannot make term int

adding quantifiers


\item Prototype 2 does
extends current prolog-0.2.0.1
this is to show that we can plug out approach into existing implementation and things work

\item Prototype 3 does
variable search strategy
what ever method you do for searching at the point of unification you can do it with our approach

\item Prototype 4 does
how can io be squeezed into this model where whenever the resolver encounters an io operation it generates a thunk (sort of unsolved
statement) which when executed would result in a side effect but till that point every thing is pure

\end{enumerate}
\end{comment}


\section{Chapter Recapitulation}
Recapitulating, this chapter provides a brief look into each of the prototypes and the ideas behind them.

\ifMain
\begin{scope}
  \nolinenumbers
  \enotesize
  \par
  \begin{singlespace}
  \setlength{\parskip}{12pt plus 2pt minus 1pt}
  \theendnotes
  \par
  \end{singlespace}
\end{scope}
\unbcbibliography{bibliography}
\fi

\end{document}
