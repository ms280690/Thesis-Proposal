\documentclass[thesis-solanki.tex]{subfiles}


\ifMain
\externaldocument{thesis-solanki}
\fi
\begin{document}

%-----------------------------------------------------------------------------
\chapter{Accomplished Work}\label{chap:accomplishedWork}
%-----------------------------------------------------------------------------

\section{What this chapter is about}\label{sec:what-this-chapter:accomplishedWork}
This chapter provides the details for the conceptual contributions of this thesis along with information on the implementation of each 
prototype. Moreover, we state the other 'soft'\mehul{surveys, making libraries work etc etc} contributions of this thesis.



\section{Conceptual Advances beyond Section~\ref{sec:things-fixed}}\label{sec:advances:accomplishedWork}

\begin{enumerate}
\item provide a modular methodology to functorize a recursive abstract grammar used to define a language,

\item modular monadic unification to leverage imperative unification algorithms,

\item integrate the procedures mentioned above into a working \prologConstruct{Prolog} implementation,

\item support for variable search strategies,

\item approach for embedding IO in eDSL.

\end{enumerate}

\section{What the prototypes contain}
\subsection{What Prototype 1 contains}

Most languages have a recursive abstract syntax which restricts the embedded, domain-specific language
  \enparen{eDSL, see p.~\pageref{sec:DSL-def}}\endnote{%  
    See Note~\eref{eDSL1}, then remove this.
}
  in terms of its capability to \textit{open up} the language, i.e, to include meta syntactic
  variables, custom quantifiers and logic.
  (\chapterReference{proto1}{Prototype 1}) provides a methodology to convert a language whose recursive abstract
  syntax is represented by a tree into a non-recursive version whose fixed point is isomorphically equivalent to
  the original type.
  One of the outcomes is a producing a polymorphically typed embedded language within \progLang{Haskell}.

  To test it out we adopt the closed \progLang{Prolog}-like language defined in \cite{prolog-lib} and open it up.
  As for the unification part we use \cite{unification-fd-lib}, which provides a generic unification algorithm
  implementation encapsulated into a monad.


\subsection{What Prototype 2 contains}

  (\chapterReference{proto2}{Prototype 2}) does the what a \progLang{Prolog} query resolver would do given a
  query and a knowledge base.
  The mechanism for the same is adopted from \cite{prolog-lib}.
  The embedded language is modified as per the procedure in (\chapterReference{proto1}{Prototype 1}) and the
  monadic unification part is plugged into the existing architecture to demonstrate that it is independent of the
  other components.
  Lastly the result is converted into the original language via a translate function.

\subsection{What Prototype 3 contains}

  (\chapterReference{proto3}{Prototype 3}) demonstrates the modularity of the unification process of the query
  resolver with multiple search strategies.

\subsection{What Prototype 4 contains}

  (\chapterReference{proto4}{Prototype 4}) throws light on how IO operations can be embedded into the abstract
  syntax of a DSL which when interpreted would produce output consisting of a pure set of instructions irrespective
  of the nature of the construct.
  The effects are only produced only when the actions are executed.


\begin{comment}
\section{Thesis Improved Contributions}\label{sec:thes-impr-contr}

\begin{enumerate}
\item Prototype 1 does
flattening language
opening up the language (binding monad)
adding custom variables
monadic unification (stuff happens in a bubble)
rec type $\rightarrow$ non rec type $\rightarrow$ fix non rec type isomorphically == rec type

You can make an Flatterm int

but you cannot make term int

adding quantifiers


\item Prototype 2 does
extends current prolog-0.2.0.1
this is to show that we can plug out approach into existing implementation and things work

\item Prototype 3 does
variable search strategy
what ever method you do for searching at the point of unification you can do it with our approach

\item Prototype 4 does
how can io be squeezed into this model where whenever the resolver encounters an io operation it generates a thunk (sort of unsolved
statement) which when executed would result in a side effect but till that point every thing is pure

\end{enumerate}
\end{comment}


\section{What work was done in terms of points}\label{sec:work-in-points}
\begin{enumerate}
\item Literature review on eDSL's.

\item Short survey on multi paradigm declarative languages.

\item Accumulated and evaluated \progLang{Prolog} in \progLang{Haskell}.

\item Defined a procedure to open up a language starting from a generic recursive abstract syntax.

\item Made a few libraries to work together.

\item Some stuff for monadic unification.

\item Something to show it was modular and independent of the original grammar.

\item
  Something to show that the unification part is independent of the search strategy and hence multiple ones can be
  used, possibly simultaneously to find a solution.

\item
  Creating a micro language to represent and encapsulate IO operation in an eDSL so that the it remains pure even
  after interpretation and only produces side effects when the action is actually executed and hence in some way it
  can be controlled.

\end{enumerate}

Furthermore, this thesis provides a literature review on embedded domain specific languages in Chapter~\ref{chap:embedding} and a survey on
multi paradigm declarative languages in Chapter~\ref{chap:multiparadigm}. The current chapter and Chapter~\ref{chap:proposedWork} evaluate 
and access the current work in embedding \progLang{Prolog} in \progLang{Haskell}.  Creating a micro language to represent and encapsulate 
IO operation in an eDSL so that the it remains pure even after interpretation and only produces side effects when the action is actually 
executed and hence in some way it can be controlled.


\section{Chapter Recapitulation}
Recapitulating, this chapter provides a brief look into each of the prototypes and the ideas behind them.

\ifMain
\begin{scope}
  \nolinenumbers
  \enotesize
  \par
  \begin{singlespace}
  \setlength{\parskip}{12pt plus 2pt minus 1pt}
  \theendnotes
  \par
  \end{singlespace}
\end{scope}
\unbcbibliography{bibliography}
\fi

\end{document}
